// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`GraphQLSchema creates a consistent valid GraphQL schema 1`] = `
"# An article
type Article {
  # The public ID
  id: ID!

  # The date, fixed, of the document's creation
  createdAt: DateTime!

  # The date of the document's last update
  updatedAt: DateTime!

  # An \\"auto-increment\\" kind of field
  computedMaxIntId: Int!

  # The date of the document's public release
  publishedAt: DateTime
  format: ArticleFormat!

  # The article's title
  title: String!

  # The article's slug
  slug: String!

  # The article's body
  body: String

  # The day of the document's public release
  publicationDay: Date

  # The time of the document's public release
  publicationTime: Time

  # Either this article is published or not
  isPublished: Boolean!

  # Either this article is important or not
  isImportant: Boolean

  # The article's category
  category: Category!
  author: User!
  moderator: User

  # \\"ArticleTag.article\\"'s inverse relation
  tags(where: ArticleTagWhereInput, orderBy: [ArticleTagOrderByInput!], first: Int!, skip: Int): [ArticleTag!]!

  # \\"ArticleTag.article\\"'s inverse relation count
  tagCount(where: ArticleTagWhereInput): Int!

  # \\"ArticleUrl.article\\"'s inverse relation
  url: ArticleUrl

  # Exemple of virtual field dependant of the field \\"title\\".
  lowerCasedTitle: String!
}

input ArticleCreateInput {
  # The public ID
  id: ID

  # The date of the document's public release
  publishedAt: DateTime
  format: ArticleFormat!

  # The article's title
  title: String!

  # The article's slug
  slug: String

  # The article's body
  body: String

  # Either this article is important or not
  isImportant: Boolean

  # Actions for the \\"Article.category\\" relation: The article's category
  category: ArticleNestedCategoryCreateInput!

  # Actions for the \\"Article.author\\" relation
  author: ArticleNestedAuthorCreateInput!

  # Actions for the \\"Article.moderator\\" relation
  moderator: ArticleNestedModeratorCreateInput

  # Actions for the \\"Article.tags\\" relation: \\"ArticleTag.article\\"'s inverse relation
  tags: ArticleNestedTagsCreateInput

  # Actions for the \\"Article.url\\" relation: \\"ArticleUrl.article\\"'s inverse relation
  url: ArticleNestedUrlCreateInput
}

enum ArticleFormat {
  Rich
  Video
}

input ArticleNestedAuthorCreateInput {
  # Connect an existing \\"User\\" node to the new \\"Article\\" node, through the \\"Article.author\\" relation.
  connect: UserWhereUniqueInput

  # Update an existing \\"User\\" node and connect it to the new \\"Article\\" node, through the \\"Article.author\\" relation.
  update: ArticleNestedUpdateAuthorCreateInput

  # Create a new \\"User\\" node and connect it to the new \\"Article\\" node, through the \\"Article.author\\" relation.
  create: UserCreateInput

  # Create or update a \\"User\\" node and connect it to the new \\"Article\\" node, through the \\"Article.author\\" relation.
  upsert: ArticleNestedUpsertAuthorCreateInput
}

input ArticleNestedAuthorUpdateInput {
  # Connect an existing \\"User\\" node to the existing \\"Article\\" node, through the \\"Article.author\\" relation.
  connect: UserWhereUniqueInput

  # Update an existing \\"User\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.author\\" relation.
  update: ArticleNestedUpdateAuthorUpdateInput

  # Create a new \\"User\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.author\\" relation.
  create: UserCreateInput

  # Create or update a \\"User\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.author\\" relation.
  upsert: ArticleNestedUpsertAuthorUpdateInput
}

input ArticleNestedCategoryCreateInput {
  # Connect an existing \\"Category\\" node to the new \\"Article\\" node, through the \\"Article.category\\" relation.
  connect: CategoryWhereUniqueInput

  # Update an existing \\"Category\\" node and connect it to the new \\"Article\\" node, through the \\"Article.category\\" relation.
  update: ArticleNestedUpdateCategoryCreateInput

  # Create a new \\"Category\\" node and connect it to the new \\"Article\\" node, through the \\"Article.category\\" relation.
  create: CategoryCreateInput

  # Create or update a \\"Category\\" node and connect it to the new \\"Article\\" node, through the \\"Article.category\\" relation.
  upsert: ArticleNestedUpsertCategoryCreateInput
}

input ArticleNestedCategoryUpdateInput {
  # Connect an existing \\"Category\\" node to the existing \\"Article\\" node, through the \\"Article.category\\" relation.
  connect: CategoryWhereUniqueInput

  # Update an existing \\"Category\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.category\\" relation.
  update: ArticleNestedUpdateCategoryUpdateInput

  # Create a new \\"Category\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.category\\" relation.
  create: CategoryCreateInput

  # Create or update a \\"Category\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.category\\" relation.
  upsert: ArticleNestedUpsertCategoryUpdateInput
}

input ArticleNestedModeratorCreateInput {
  # Connect an existing \\"User\\" node to the new \\"Article\\" node, through the \\"Article.moderator\\" relation.
  connect: UserWhereUniqueInput

  # Update an existing \\"User\\" node and connect it to the new \\"Article\\" node, through the \\"Article.moderator\\" relation.
  update: ArticleNestedUpdateModeratorCreateInput

  # Create a new \\"User\\" node and connect it to the new \\"Article\\" node, through the \\"Article.moderator\\" relation.
  create: UserCreateInput

  # Create or update a \\"User\\" node and connect it to the new \\"Article\\" node, through the \\"Article.moderator\\" relation.
  upsert: ArticleNestedUpsertModeratorCreateInput
}

input ArticleNestedModeratorUpdateInput {
  # Connect an existing \\"User\\" node to the existing \\"Article\\" node, through the \\"Article.moderator\\" relation.
  connect: UserWhereUniqueInput

  # Update an existing \\"User\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.moderator\\" relation.
  update: ArticleNestedUpdateModeratorUpdateInput

  # Create a new \\"User\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.moderator\\" relation.
  create: UserCreateInput

  # Create or update a \\"User\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.moderator\\" relation.
  upsert: ArticleNestedUpsertModeratorUpdateInput

  # Disconnect the current connected \\"User\\" node, if any, of the \\"Article.moderator\\" relation.
  disconnect: Boolean
}

input ArticleNestedTagsCreateInput {
  # Create new \\"ArticleTag\\" nodes and connect them to the new \\"Article\\" node, through the \\"Article.tags\\" relation.
  create: [ArticleTagWithForcedArticleCreateInput!]
}

input ArticleNestedTagsUpdateInput {
  # Update existing \\"ArticleTag\\" nodes and connect them to the existing \\"Article\\" node, through the \\"Article.tags\\" relation.
  update: [ArticleNestedUpdateTagsUpdateInput!]

  # Create new \\"ArticleTag\\" nodes and connect them to the existing \\"Article\\" node, through the \\"Article.tags\\" relation.
  create: [ArticleTagWithForcedArticleCreateInput!]

  # Upsert existing \\"ArticleTag\\" nodes and connect them to the existing \\"Article\\" node, through the \\"Article.tags\\" relation.
  upsert: [ArticleNestedUpsertTagsUpdateInput!]

  # Delete existing \\"ArticleTag\\" nodes from the \\"Article.tags\\" relation.
  delete: [ArticleTagWithForcedArticleWhereUniqueInput!]
}

input ArticleNestedUpdateAuthorCreateInput {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input ArticleNestedUpdateAuthorUpdateInput {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input ArticleNestedUpdateCategoryCreateInput {
  where: CategoryWhereUniqueInput!
  data: CategoryUpdateInput!
}

input ArticleNestedUpdateCategoryUpdateInput {
  where: CategoryWhereUniqueInput!
  data: CategoryUpdateInput!
}

input ArticleNestedUpdateModeratorCreateInput {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input ArticleNestedUpdateModeratorUpdateInput {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input ArticleNestedUpdateTagsUpdateInput {
  where: ArticleTagWithForcedArticleWhereUniqueInput!
  data: ArticleTagWithForcedArticleUpdateInput!
}

input ArticleNestedUpdateUrlUpdateInput {
  data: ArticleUrlWithForcedArticleUpdateInput!
}

input ArticleNestedUpsertAuthorCreateInput {
  where: UserWhereUniqueInput!
  update: UserUpdateInput!
  create: UserCreateInput!
}

input ArticleNestedUpsertAuthorUpdateInput {
  where: UserWhereUniqueInput!
  update: UserUpdateInput!
  create: UserCreateInput!
}

input ArticleNestedUpsertCategoryCreateInput {
  where: CategoryWhereUniqueInput!
  update: CategoryUpdateInput!
  create: CategoryCreateInput!
}

input ArticleNestedUpsertCategoryUpdateInput {
  where: CategoryWhereUniqueInput!
  update: CategoryUpdateInput!
  create: CategoryCreateInput!
}

input ArticleNestedUpsertModeratorCreateInput {
  where: UserWhereUniqueInput!
  update: UserUpdateInput!
  create: UserCreateInput!
}

input ArticleNestedUpsertModeratorUpdateInput {
  where: UserWhereUniqueInput!
  update: UserUpdateInput!
  create: UserCreateInput!
}

input ArticleNestedUpsertTagsUpdateInput {
  where: ArticleTagWithForcedArticleWhereUniqueInput!
  update: ArticleTagWithForcedArticleUpdateInput!
  create: ArticleTagWithForcedArticleCreateInput!
}

input ArticleNestedUpsertUrlUpdateInput {
  update: ArticleUrlWithForcedArticleUpdateInput!
  create: ArticleUrlWithForcedArticleCreateInput!
}

input ArticleNestedUrlCreateInput {
  # Create a new \\"ArticleUrl\\" node and connect it to the new \\"Article\\" node, through the \\"Article.url\\" relation.
  create: ArticleUrlWithForcedArticleCreateInput
}

input ArticleNestedUrlUpdateInput {
  # Update an existing \\"ArticleUrl\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.url\\" relation.
  update: ArticleNestedUpdateUrlUpdateInput

  # Create a new \\"ArticleUrl\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.url\\" relation.
  create: ArticleUrlWithForcedArticleCreateInput

  # Upsert an existing \\"ArticleUrl\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.url\\" relation.
  upsert: ArticleNestedUpsertUrlUpdateInput

  # Delete an existing \\"ArticleUrl\\" node from the \\"Article.url\\" relation.
  delete: Boolean
}

enum ArticleOrderByInput {
  _id_ASC
  _id_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  computedMaxIntId_ASC
  computedMaxIntId_DESC
  publishedAt_ASC
  publishedAt_DESC
  format_ASC
  format_DESC
  title_ASC
  title_DESC
  slug_ASC
  slug_DESC
  body_ASC
  body_DESC
  publicationDay_ASC
  publicationDay_DESC
  publicationTime_ASC
  publicationTime_DESC
  isPublished_ASC
  isPublished_DESC
  isImportant_ASC
  isImportant_DESC
}

# \\"ArticleTag\\" resource's node
type ArticleTag {
  # The date, fixed, of the document's creation
  createdAt: DateTime!

  # The date of the document's last update
  updatedAt: DateTime!
  order: Int!
  article: Article!
  tag: Tag!

  # \\"ArticleTagComment.articleTag\\"'s inverse relation
  comment: ArticleTagComment
}

# \\"ArticleTagComment\\" resource's node
type ArticleTagComment {
  # The date, fixed, of the document's creation
  createdAt: DateTime!

  # The date of the document's last update
  updatedAt: DateTime!
  body: String
  articleTag: ArticleTag!
}

input ArticleTagCommentCreateInput {
  body: String

  # Actions for the \\"ArticleTagComment.articleTag\\" relation
  articleTag: ArticleTagCommentNestedArticleTagCreateInput!
}

input ArticleTagCommentNestedArticleTagCreateInput {
  # Connect an existing \\"ArticleTag\\" node to the new \\"ArticleTagComment\\" node,
  # through the \\"ArticleTagComment.articleTag\\" relation.
  connect: ArticleTagWhereUniqueInput

  # Update an existing \\"ArticleTag\\" node and connect it to the new
  # \\"ArticleTagComment\\" node, through the \\"ArticleTagComment.articleTag\\" relation.
  update: ArticleTagCommentNestedUpdateArticleTagCreateInput

  # Create a new \\"ArticleTag\\" node and connect it to the new \\"ArticleTagComment\\"
  # node, through the \\"ArticleTagComment.articleTag\\" relation.
  create: ArticleTagCreateInput

  # Create or update a \\"ArticleTag\\" node and connect it to the new
  # \\"ArticleTagComment\\" node, through the \\"ArticleTagComment.articleTag\\" relation.
  upsert: ArticleTagCommentNestedUpsertArticleTagCreateInput
}

input ArticleTagCommentNestedUpdateArticleTagCreateInput {
  where: ArticleTagWhereUniqueInput!
  data: ArticleTagUpdateInput!
}

input ArticleTagCommentNestedUpsertArticleTagCreateInput {
  where: ArticleTagWhereUniqueInput!
  update: ArticleTagUpdateInput!
  create: ArticleTagCreateInput!
}

enum ArticleTagCommentOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  body_ASC
  body_DESC
}

input ArticleTagCommentUpdateInput {
  body: String
}

# Filters the \\"ArticleTagComment\\" nodes by specifying some conditions
input ArticleTagCommentWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  body: String
  body_not: String
  body_is_null: Boolean
  body_in: [String]
  body_not_in: [String]
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  articleTag: ArticleTagWhereInput
  AND: [ArticleTagCommentWhereInput!]
  OR: [ArticleTagCommentWhereInput!]
  NOT: ArticleTagCommentWhereInput
}

# Identifies exactly one \\"ArticleTagComment\\" node.
input ArticleTagCommentWhereUniqueInput {
  articleTag: ArticleTagWhereUniqueInput!
}

input ArticleTagCommentWithForcedArticleTagCreateInput {
  body: String
}

input ArticleTagCommentWithForcedArticleTagUpdateInput {
  body: String
}

input ArticleTagCreateInput {
  order: Int!

  # Actions for the \\"ArticleTag.article\\" relation
  article: ArticleTagNestedArticleCreateInput!

  # Actions for the \\"ArticleTag.tag\\" relation
  tag: ArticleTagNestedTagCreateInput!

  # Actions for the \\"ArticleTag.comment\\" relation: \\"ArticleTagComment.articleTag\\"'s inverse relation
  comment: ArticleTagNestedCommentCreateInput
}

input ArticleTagNestedArticleCreateInput {
  # Connect an existing \\"Article\\" node to the new \\"ArticleTag\\" node, through the \\"ArticleTag.article\\" relation.
  connect: ArticleWhereUniqueInput

  # Update an existing \\"Article\\" node and connect it to the new \\"ArticleTag\\" node, through the \\"ArticleTag.article\\" relation.
  update: ArticleTagNestedUpdateArticleCreateInput

  # Create a new \\"Article\\" node and connect it to the new \\"ArticleTag\\" node, through the \\"ArticleTag.article\\" relation.
  create: ArticleCreateInput

  # Create or update a \\"Article\\" node and connect it to the new \\"ArticleTag\\" node, through the \\"ArticleTag.article\\" relation.
  upsert: ArticleTagNestedUpsertArticleCreateInput
}

input ArticleTagNestedCommentCreateInput {
  # Create a new \\"ArticleTagComment\\" node and connect it to the new \\"ArticleTag\\"
  # node, through the \\"ArticleTag.comment\\" relation.
  create: ArticleTagCommentWithForcedArticleTagCreateInput
}

input ArticleTagNestedCommentUpdateInput {
  # Update an existing \\"ArticleTagComment\\" node and connect it to the existing
  # \\"ArticleTag\\" node, through the \\"ArticleTag.comment\\" relation.
  update: ArticleTagNestedUpdateCommentUpdateInput

  # Create a new \\"ArticleTagComment\\" node and connect it to the existing
  # \\"ArticleTag\\" node, through the \\"ArticleTag.comment\\" relation.
  create: ArticleTagCommentWithForcedArticleTagCreateInput

  # Upsert an existing \\"ArticleTagComment\\" node and connect it to the existing
  # \\"ArticleTag\\" node, through the \\"ArticleTag.comment\\" relation.
  upsert: ArticleTagNestedUpsertCommentUpdateInput

  # Delete an existing \\"ArticleTagComment\\" node from the \\"ArticleTag.comment\\" relation.
  delete: Boolean
}

input ArticleTagNestedTagCreateInput {
  # Connect an existing \\"Tag\\" node to the new \\"ArticleTag\\" node, through the \\"ArticleTag.tag\\" relation.
  connect: TagWhereUniqueInput

  # Create a new \\"Tag\\" node and connect it to the new \\"ArticleTag\\" node, through the \\"ArticleTag.tag\\" relation.
  create: TagCreateInput
}

input ArticleTagNestedUpdateArticleCreateInput {
  where: ArticleWhereUniqueInput!
  data: ArticleUpdateInput!
}

input ArticleTagNestedUpdateCommentUpdateInput {
  data: ArticleTagCommentWithForcedArticleTagUpdateInput!
}

input ArticleTagNestedUpsertArticleCreateInput {
  where: ArticleWhereUniqueInput!
  update: ArticleUpdateInput!
  create: ArticleCreateInput!
}

input ArticleTagNestedUpsertCommentUpdateInput {
  update: ArticleTagCommentWithForcedArticleTagUpdateInput!
  create: ArticleTagCommentWithForcedArticleTagCreateInput!
}

enum ArticleTagOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  order_ASC
  order_DESC
}

input ArticleTagUpdateInput {
  order: Int

  # Actions for the \\"ArticleTag.comment\\" relation: \\"ArticleTagComment.articleTag\\"'s inverse relation
  comment: ArticleTagNestedCommentUpdateInput
}

# Filters the \\"ArticleTag\\" nodes by specifying some conditions
input ArticleTagWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  article: ArticleWhereInput
  tag: TagWhereInput
  comment: ArticleTagCommentWhereInput
  comment_is_null: Boolean
  AND: [ArticleTagWhereInput!]
  OR: [ArticleTagWhereInput!]
  NOT: ArticleTagWhereInput
}

# Identifies exactly one \\"ArticleTag\\" node with one of these unique combinations of values:
# - article, tag
# - article, order
input ArticleTagWhereUniqueInput {
  article: ArticleWhereUniqueInput!
  tag: TagWhereUniqueInput
  order: Int
}

input ArticleTagWithForcedArticleCreateInput {
  order: Int!

  # Actions for the \\"ArticleTag.tag\\" relation
  tag: ArticleTagNestedTagCreateInput!

  # Actions for the \\"ArticleTag.comment\\" relation: \\"ArticleTagComment.articleTag\\"'s inverse relation
  comment: ArticleTagNestedCommentCreateInput
}

input ArticleTagWithForcedArticleUpdateInput {
  order: Int

  # Actions for the \\"ArticleTag.comment\\" relation: \\"ArticleTagComment.articleTag\\"'s inverse relation
  comment: ArticleTagNestedCommentUpdateInput
}

# Given a forced \\"article\\", identifies exactly one \\"ArticleTag\\" node with one of these unique values:
# - tag
# - order
input ArticleTagWithForcedArticleWhereUniqueInput {
  tag: TagWhereUniqueInput
  order: Int
}

input ArticleTagWithForcedTagCreateInput {
  order: Int!

  # Actions for the \\"ArticleTag.article\\" relation
  article: ArticleTagNestedArticleCreateInput!

  # Actions for the \\"ArticleTag.comment\\" relation: \\"ArticleTagComment.articleTag\\"'s inverse relation
  comment: ArticleTagNestedCommentCreateInput
}

input ArticleUpdateInput {
  # The public ID
  id: ID

  # The date of the document's public release
  publishedAt: DateTime
  format: ArticleFormat

  # The article's title
  title: String

  # The article's body
  body: String

  # Either this article is important or not
  isImportant: Boolean

  # Actions for the \\"Article.category\\" relation: The article's category
  category: ArticleNestedCategoryUpdateInput

  # Actions for the \\"Article.author\\" relation
  author: ArticleNestedAuthorUpdateInput

  # Actions for the \\"Article.moderator\\" relation
  moderator: ArticleNestedModeratorUpdateInput

  # Actions for the \\"Article.tags\\" relation: \\"ArticleTag.article\\"'s inverse relation
  tags: ArticleNestedTagsUpdateInput

  # Actions for the \\"Article.url\\" relation: \\"ArticleUrl.article\\"'s inverse relation
  url: ArticleNestedUrlUpdateInput
}

# \\"ArticleUrl\\" resource's node
type ArticleUrl {
  # The date, fixed, of the document's creation
  createdAt: DateTime!

  # The date of the document's last update
  updatedAt: DateTime!
  path: String!
  article: Article!

  # \\"ArticleUrlMeta.url\\"'s inverse relation
  meta: ArticleUrlMeta
}

input ArticleUrlCreateInput {
  path: String!

  # Actions for the \\"ArticleUrl.article\\" relation
  article: ArticleUrlNestedArticleCreateInput!

  # Actions for the \\"ArticleUrl.meta\\" relation: \\"ArticleUrlMeta.url\\"'s inverse relation
  meta: ArticleUrlNestedMetaCreateInput
}

# \\"ArticleUrlMeta\\" resource's node
type ArticleUrlMeta {
  # The date, fixed, of the document's creation
  createdAt: DateTime!

  # The date of the document's last update
  updatedAt: DateTime!
  url: ArticleUrl!
}

input ArticleUrlMetaCreateInput {
  # Actions for the \\"ArticleUrlMeta.url\\" relation
  url: ArticleUrlMetaNestedUrlCreateInput!
}

input ArticleUrlMetaNestedUpdateUrlCreateInput {
  where: ArticleUrlWhereUniqueInput!
  data: ArticleUrlUpdateInput!
}

input ArticleUrlMetaNestedUpsertUrlCreateInput {
  where: ArticleUrlWhereUniqueInput!
  update: ArticleUrlUpdateInput!
  create: ArticleUrlCreateInput!
}

input ArticleUrlMetaNestedUrlCreateInput {
  # Connect an existing \\"ArticleUrl\\" node to the new \\"ArticleUrlMeta\\" node, through the \\"ArticleUrlMeta.url\\" relation.
  connect: ArticleUrlWhereUniqueInput

  # Update an existing \\"ArticleUrl\\" node and connect it to the new
  # \\"ArticleUrlMeta\\" node, through the \\"ArticleUrlMeta.url\\" relation.
  update: ArticleUrlMetaNestedUpdateUrlCreateInput

  # Create a new \\"ArticleUrl\\" node and connect it to the new \\"ArticleUrlMeta\\" node, through the \\"ArticleUrlMeta.url\\" relation.
  create: ArticleUrlCreateInput

  # Create or update a \\"ArticleUrl\\" node and connect it to the new
  # \\"ArticleUrlMeta\\" node, through the \\"ArticleUrlMeta.url\\" relation.
  upsert: ArticleUrlMetaNestedUpsertUrlCreateInput
}

enum ArticleUrlMetaOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

# Filters the \\"ArticleUrlMeta\\" nodes by specifying some conditions
input ArticleUrlMetaWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  url: ArticleUrlWhereInput
  AND: [ArticleUrlMetaWhereInput!]
  OR: [ArticleUrlMetaWhereInput!]
  NOT: ArticleUrlMetaWhereInput
}

# Identifies exactly one \\"ArticleUrlMeta\\" node.
input ArticleUrlMetaWhereUniqueInput {
  url: ArticleUrlWhereUniqueInput!
}

input ArticleUrlNestedArticleCreateInput {
  # Connect an existing \\"Article\\" node to the new \\"ArticleUrl\\" node, through the \\"ArticleUrl.article\\" relation.
  connect: ArticleWhereUniqueInput

  # Update an existing \\"Article\\" node and connect it to the new \\"ArticleUrl\\" node, through the \\"ArticleUrl.article\\" relation.
  update: ArticleUrlNestedUpdateArticleCreateInput

  # Create a new \\"Article\\" node and connect it to the new \\"ArticleUrl\\" node, through the \\"ArticleUrl.article\\" relation.
  create: ArticleCreateInput

  # Create or update a \\"Article\\" node and connect it to the new \\"ArticleUrl\\" node, through the \\"ArticleUrl.article\\" relation.
  upsert: ArticleUrlNestedUpsertArticleCreateInput
}

input ArticleUrlNestedMetaCreateInput {
  # Create a new \\"ArticleUrlMeta\\" node and connect it to the new \\"ArticleUrl\\" node, through the \\"ArticleUrl.meta\\" relation.
  create: Boolean
}

input ArticleUrlNestedMetaUpdateInput {
  # Update an existing \\"ArticleUrlMeta\\" node and connect it to the existing
  # \\"ArticleUrl\\" node, through the \\"ArticleUrl.meta\\" relation.
  update: ArticleUrlNestedUpdateMetaUpdateInput

  # Create a new \\"ArticleUrlMeta\\" node and connect it to the existing \\"ArticleUrl\\"
  # node, through the \\"ArticleUrl.meta\\" relation.
  create: Boolean

  # Upsert an existing \\"ArticleUrlMeta\\" node and connect it to the existing
  # \\"ArticleUrl\\" node, through the \\"ArticleUrl.meta\\" relation.
  upsert: ArticleUrlNestedUpsertMetaUpdateInput

  # Delete an existing \\"ArticleUrlMeta\\" node from the \\"ArticleUrl.meta\\" relation.
  delete: Boolean
}

input ArticleUrlNestedUpdateArticleCreateInput {
  where: ArticleWhereUniqueInput!
  data: ArticleUpdateInput!
}

input ArticleUrlNestedUpdateMetaUpdateInput {
  data: Boolean!
}

input ArticleUrlNestedUpsertArticleCreateInput {
  where: ArticleWhereUniqueInput!
  update: ArticleUpdateInput!
  create: ArticleCreateInput!
}

input ArticleUrlNestedUpsertMetaUpdateInput {
  update: Boolean!
  create: Boolean!
}

enum ArticleUrlOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  path_ASC
  path_DESC
}

input ArticleUrlUpdateInput {
  path: String

  # Actions for the \\"ArticleUrl.meta\\" relation: \\"ArticleUrlMeta.url\\"'s inverse relation
  meta: ArticleUrlNestedMetaUpdateInput
}

# Filters the \\"ArticleUrl\\" nodes by specifying some conditions
input ArticleUrlWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  article: ArticleWhereInput
  meta: ArticleUrlMetaWhereInput
  meta_is_null: Boolean
  AND: [ArticleUrlWhereInput!]
  OR: [ArticleUrlWhereInput!]
  NOT: ArticleUrlWhereInput
}

# Identifies exactly one \\"ArticleUrl\\" node.
input ArticleUrlWhereUniqueInput {
  article: ArticleWhereUniqueInput!
}

input ArticleUrlWithForcedArticleCreateInput {
  path: String!

  # Actions for the \\"ArticleUrl.meta\\" relation: \\"ArticleUrlMeta.url\\"'s inverse relation
  meta: ArticleUrlNestedMetaCreateInput
}

input ArticleUrlWithForcedArticleUpdateInput {
  path: String

  # Actions for the \\"ArticleUrl.meta\\" relation: \\"ArticleUrlMeta.url\\"'s inverse relation
  meta: ArticleUrlNestedMetaUpdateInput
}

# Filters the \\"Article\\" nodes by specifying some conditions
input ArticleWhereInput {
  _id: Int
  _id_not: Int
  _id_in: [Int!]
  _id_not_in: [Int!]
  _id_lt: Int
  _id_lte: Int
  _id_gt: Int
  _id_gte: Int
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  computedMaxIntId: Int
  computedMaxIntId_not: Int
  computedMaxIntId_in: [Int!]
  computedMaxIntId_not_in: [Int!]
  computedMaxIntId_lt: Int
  computedMaxIntId_lte: Int
  computedMaxIntId_gt: Int
  computedMaxIntId_gte: Int
  publishedAt: DateTime
  publishedAt_not: DateTime
  publishedAt_is_null: Boolean
  publishedAt_in: [DateTime]
  publishedAt_not_in: [DateTime]
  publishedAt_lt: DateTime
  publishedAt_lte: DateTime
  publishedAt_gt: DateTime
  publishedAt_gte: DateTime
  format: ArticleFormat
  format_not: ArticleFormat
  format_in: [ArticleFormat!]
  format_not_in: [ArticleFormat!]
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  body: String
  body_not: String
  body_is_null: Boolean
  body_in: [String]
  body_not_in: [String]
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  publicationDay: Date
  publicationDay_not: Date
  publicationDay_is_null: Boolean
  publicationDay_in: [Date]
  publicationDay_not_in: [Date]
  publicationDay_lt: Date
  publicationDay_lte: Date
  publicationDay_gt: Date
  publicationDay_gte: Date
  publicationTime: Time
  publicationTime_not: Time
  publicationTime_is_null: Boolean
  publicationTime_in: [Time]
  publicationTime_not_in: [Time]
  publicationTime_lt: Time
  publicationTime_lte: Time
  publicationTime_gt: Time
  publicationTime_gte: Time
  isPublished: Boolean
  isPublished_not: Boolean
  isPublished_in: [Boolean!]
  isPublished_not_in: [Boolean!]
  isImportant: Boolean
  isImportant_not: Boolean
  isImportant_is_null: Boolean
  isImportant_in: [Boolean]
  isImportant_not_in: [Boolean]
  category: CategoryWhereInput
  author: UserWhereInput
  moderator: UserWhereInput
  moderator_is_null: Boolean
  tags_some: ArticleTagWhereInput
  url: ArticleUrlWhereInput
  url_is_null: Boolean
  AND: [ArticleWhereInput!]
  OR: [ArticleWhereInput!]
  NOT: ArticleWhereInput
}

# Identifies exactly one \\"Article\\" node with one of these unique combinations of values:
# - _id
# - id
# - computedMaxIntId
# - category, slug
input ArticleWhereUniqueInput {
  _id: Int
  id: ID
  computedMaxIntId: Int
  category: CategoryWhereUniqueInput
  slug: String
}

input ArticleWithForcedAuthorCreateInput {
  # The public ID
  id: ID

  # The date of the document's public release
  publishedAt: DateTime
  format: ArticleFormat!

  # The article's title
  title: String!

  # The article's slug
  slug: String

  # The article's body
  body: String

  # Either this article is important or not
  isImportant: Boolean

  # Actions for the \\"Article.category\\" relation: The article's category
  category: ArticleNestedCategoryCreateInput!

  # Actions for the \\"Article.moderator\\" relation
  moderator: ArticleNestedModeratorCreateInput

  # Actions for the \\"Article.tags\\" relation: \\"ArticleTag.article\\"'s inverse relation
  tags: ArticleNestedTagsCreateInput

  # Actions for the \\"Article.url\\" relation: \\"ArticleUrl.article\\"'s inverse relation
  url: ArticleNestedUrlCreateInput
}

input ArticleWithForcedAuthorUpdateInput {
  # The public ID
  id: ID

  # The date of the document's public release
  publishedAt: DateTime
  format: ArticleFormat

  # The article's title
  title: String

  # The article's body
  body: String

  # Either this article is important or not
  isImportant: Boolean

  # Actions for the \\"Article.category\\" relation: The article's category
  category: ArticleNestedCategoryUpdateInput

  # Actions for the \\"Article.moderator\\" relation
  moderator: ArticleNestedModeratorUpdateInput

  # Actions for the \\"Article.tags\\" relation: \\"ArticleTag.article\\"'s inverse relation
  tags: ArticleNestedTagsUpdateInput

  # Actions for the \\"Article.url\\" relation: \\"ArticleUrl.article\\"'s inverse relation
  url: ArticleNestedUrlUpdateInput
}

input ArticleWithForcedCategoryCreateInput {
  # The public ID
  id: ID

  # The date of the document's public release
  publishedAt: DateTime
  format: ArticleFormat!

  # The article's title
  title: String!

  # The article's slug
  slug: String

  # The article's body
  body: String

  # Either this article is important or not
  isImportant: Boolean

  # Actions for the \\"Article.author\\" relation
  author: ArticleNestedAuthorCreateInput!

  # Actions for the \\"Article.moderator\\" relation
  moderator: ArticleNestedModeratorCreateInput

  # Actions for the \\"Article.tags\\" relation: \\"ArticleTag.article\\"'s inverse relation
  tags: ArticleNestedTagsCreateInput

  # Actions for the \\"Article.url\\" relation: \\"ArticleUrl.article\\"'s inverse relation
  url: ArticleNestedUrlCreateInput
}

input ArticleWithForcedCategoryUpdateInput {
  # The public ID
  id: ID

  # The date of the document's public release
  publishedAt: DateTime
  format: ArticleFormat

  # The article's title
  title: String

  # The article's body
  body: String

  # Either this article is important or not
  isImportant: Boolean

  # Actions for the \\"Article.author\\" relation
  author: ArticleNestedAuthorUpdateInput

  # Actions for the \\"Article.moderator\\" relation
  moderator: ArticleNestedModeratorUpdateInput

  # Actions for the \\"Article.tags\\" relation: \\"ArticleTag.article\\"'s inverse relation
  tags: ArticleNestedTagsUpdateInput

  # Actions for the \\"Article.url\\" relation: \\"ArticleUrl.article\\"'s inverse relation
  url: ArticleNestedUrlUpdateInput
}

# Given a forced \\"category\\", identifies exactly one \\"Article\\" node.
input ArticleWithForcedCategoryWhereUniqueInput {
  slug: String!
}

input ArticleWithForcedModeratorCreateInput {
  # The public ID
  id: ID

  # The date of the document's public release
  publishedAt: DateTime
  format: ArticleFormat!

  # The article's title
  title: String!

  # The article's slug
  slug: String

  # The article's body
  body: String

  # Either this article is important or not
  isImportant: Boolean

  # Actions for the \\"Article.category\\" relation: The article's category
  category: ArticleNestedCategoryCreateInput!

  # Actions for the \\"Article.author\\" relation
  author: ArticleNestedAuthorCreateInput!

  # Actions for the \\"Article.tags\\" relation: \\"ArticleTag.article\\"'s inverse relation
  tags: ArticleNestedTagsCreateInput

  # Actions for the \\"Article.url\\" relation: \\"ArticleUrl.article\\"'s inverse relation
  url: ArticleNestedUrlCreateInput
}

input ArticleWithForcedModeratorUpdateInput {
  # The public ID
  id: ID

  # The date of the document's public release
  publishedAt: DateTime
  format: ArticleFormat

  # The article's title
  title: String

  # The article's body
  body: String

  # Either this article is important or not
  isImportant: Boolean

  # Actions for the \\"Article.category\\" relation: The article's category
  category: ArticleNestedCategoryUpdateInput

  # Actions for the \\"Article.author\\" relation
  author: ArticleNestedAuthorUpdateInput

  # Actions for the \\"Article.tags\\" relation: \\"ArticleTag.article\\"'s inverse relation
  tags: ArticleNestedTagsUpdateInput

  # Actions for the \\"Article.url\\" relation: \\"ArticleUrl.article\\"'s inverse relation
  url: ArticleNestedUrlUpdateInput
}

# Given a known \\"category\\", identifies exactly one \\"Article\\" node with one of these unique combinations of values:
# - _id
# - id
# - computedMaxIntId
# - category (optional), slug
input ArticleWithOptionalCategoryWhereUniqueInput {
  _id: Int
  id: ID
  computedMaxIntId: Int
  category: CategoryWhereUniqueInput
  slug: String
}

# \\"Category\\" resource's node
type Category {
  # The public ID
  id: ID!

  # The date, fixed, of the document's creation
  createdAt: DateTime!

  # The date of the document's last update
  updatedAt: DateTime!
  title: String!

  # The category's slug
  slug: String!
  parent: Category

  # \\"Article.category\\"'s inverse relation
  articles(where: ArticleWhereInput, orderBy: [ArticleOrderByInput!], first: Int!, skip: Int): [Article!]!

  # \\"Article.category\\"'s inverse relation count
  articleCount(where: ArticleWhereInput): Int!

  # \\"Category.parent\\"'s inverse relation
  children(where: CategoryWhereInput, orderBy: [CategoryOrderByInput!], first: Int!, skip: Int): [Category!]!

  # \\"Category.parent\\"'s inverse relation count
  childCount(where: CategoryWhereInput): Int!
}

input CategoryCreateInput {
  # The public ID
  id: ID
  title: String!

  # The category's slug
  slug: String

  # Actions for the \\"Category.parent\\" relation
  parent: CategoryNestedParentCreateInput

  # Actions for the \\"Category.articles\\" relation: \\"Article.category\\"'s inverse relation
  articles: CategoryNestedArticlesCreateInput

  # Actions for the \\"Category.children\\" relation: \\"Category.parent\\"'s inverse relation
  children: CategoryNestedChildrenCreateInput
}

input CategoryNestedArticlesCreateInput {
  # Connect existing \\"Article\\" nodes to the new \\"Category\\" node, through the \\"Category.articles\\" relation.
  connect: [ArticleWhereUniqueInput!]

  # Create new \\"Article\\" nodes and connect them to the new \\"Category\\" node, through the \\"Category.articles\\" relation.
  create: [ArticleWithForcedCategoryCreateInput!]
}

input CategoryNestedArticlesUpdateInput {
  # Connect existing \\"Article\\" nodes to the existing \\"Category\\" node, through the \\"Category.articles\\" relation.
  connect: [ArticleWhereUniqueInput!]

  # Update existing \\"Article\\" nodes and connect them to the existing \\"Category\\"
  # node, through the \\"Category.articles\\" relation.
  update: [CategoryNestedUpdateArticlesUpdateInput!]

  # Create new \\"Article\\" nodes and connect them to the existing \\"Category\\" node, through the \\"Category.articles\\" relation.
  create: [ArticleWithForcedCategoryCreateInput!]

  # Upsert existing \\"Article\\" nodes and connect them to the existing \\"Category\\"
  # node, through the \\"Category.articles\\" relation.
  upsert: [CategoryNestedUpsertArticlesUpdateInput!]

  # Delete existing \\"Article\\" nodes from the \\"Category.articles\\" relation.
  delete: [ArticleWithForcedCategoryWhereUniqueInput!]
}

input CategoryNestedChildrenCreateInput {
  # Connect existing \\"Category\\" nodes to the new \\"Category\\" node, through the \\"Category.children\\" relation.
  connect: [CategoryWhereUniqueInput!]

  # Create new \\"Category\\" nodes and connect them to the new \\"Category\\" node, through the \\"Category.children\\" relation.
  create: [CategoryWithForcedParentCreateInput!]
}

input CategoryNestedChildrenUpdateInput {
  # Connect existing \\"Category\\" nodes to the existing \\"Category\\" node, through the \\"Category.children\\" relation.
  connect: [CategoryWhereUniqueInput!]

  # Disconnect existing \\"Category\\" nodes of the \\"Category.children\\" relation.
  disconnect: [CategoryWithForcedParentWhereUniqueInput!]

  # Update existing \\"Category\\" nodes and connect them to the existing \\"Category\\"
  # node, through the \\"Category.children\\" relation.
  update: [CategoryNestedUpdateChildrenUpdateInput!]

  # Create new \\"Category\\" nodes and connect them to the existing \\"Category\\" node, through the \\"Category.children\\" relation.
  create: [CategoryWithForcedParentCreateInput!]

  # Upsert existing \\"Category\\" nodes and connect them to the existing \\"Category\\"
  # node, through the \\"Category.children\\" relation.
  upsert: [CategoryNestedUpsertChildrenUpdateInput!]

  # Delete existing \\"Category\\" nodes from the \\"Category.children\\" relation.
  delete: [CategoryWithForcedParentWhereUniqueInput!]
}

input CategoryNestedParentCreateInput {
  # Connect an existing \\"Category\\" node to the new \\"Category\\" node, through the \\"Category.parent\\" relation.
  connect: CategoryWhereUniqueInput

  # Update an existing \\"Category\\" node and connect it to the new \\"Category\\" node, through the \\"Category.parent\\" relation.
  update: CategoryNestedUpdateParentCreateInput

  # Create a new \\"Category\\" node and connect it to the new \\"Category\\" node, through the \\"Category.parent\\" relation.
  create: CategoryCreateInput

  # Create or update a \\"Category\\" node and connect it to the new \\"Category\\" node, through the \\"Category.parent\\" relation.
  upsert: CategoryNestedUpsertParentCreateInput
}

input CategoryNestedParentUpdateInput {
  # Connect an existing \\"Category\\" node to the existing \\"Category\\" node, through the \\"Category.parent\\" relation.
  connect: CategoryWhereUniqueInput

  # Update an existing \\"Category\\" node and connect it to the existing \\"Category\\" node, through the \\"Category.parent\\" relation.
  update: CategoryNestedUpdateParentUpdateInput

  # Create a new \\"Category\\" node and connect it to the existing \\"Category\\" node, through the \\"Category.parent\\" relation.
  create: CategoryCreateInput

  # Create or update a \\"Category\\" node and connect it to the existing \\"Category\\" node, through the \\"Category.parent\\" relation.
  upsert: CategoryNestedUpsertParentUpdateInput

  # Disconnect the current connected \\"Category\\" node, if any, of the \\"Category.parent\\" relation.
  disconnect: Boolean
}

input CategoryNestedUpdateArticlesUpdateInput {
  where: ArticleWithOptionalCategoryWhereUniqueInput!
  data: ArticleWithForcedCategoryUpdateInput!
}

input CategoryNestedUpdateChildrenUpdateInput {
  where: CategoryWithOptionalParentWhereUniqueInput!
  data: CategoryWithForcedParentUpdateInput!
}

input CategoryNestedUpdateParentCreateInput {
  where: CategoryWhereUniqueInput!
  data: CategoryUpdateInput!
}

input CategoryNestedUpdateParentUpdateInput {
  where: CategoryWhereUniqueInput!
  data: CategoryUpdateInput!
}

input CategoryNestedUpsertArticlesUpdateInput {
  where: ArticleWithOptionalCategoryWhereUniqueInput!
  update: ArticleWithForcedCategoryUpdateInput!
  create: ArticleWithForcedCategoryCreateInput!
}

input CategoryNestedUpsertChildrenUpdateInput {
  where: CategoryWithOptionalParentWhereUniqueInput!
  update: CategoryWithForcedParentUpdateInput!
  create: CategoryWithForcedParentCreateInput!
}

input CategoryNestedUpsertParentCreateInput {
  where: CategoryWhereUniqueInput!
  update: CategoryUpdateInput!
  create: CategoryCreateInput!
}

input CategoryNestedUpsertParentUpdateInput {
  where: CategoryWhereUniqueInput!
  update: CategoryUpdateInput!
  create: CategoryCreateInput!
}

enum CategoryOrderByInput {
  _id_ASC
  _id_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
  slug_ASC
  slug_DESC
}

input CategoryUpdateInput {
  # The public ID
  id: ID
  title: String

  # Actions for the \\"Category.parent\\" relation
  parent: CategoryNestedParentUpdateInput

  # Actions for the \\"Category.articles\\" relation: \\"Article.category\\"'s inverse relation
  articles: CategoryNestedArticlesUpdateInput

  # Actions for the \\"Category.children\\" relation: \\"Category.parent\\"'s inverse relation
  children: CategoryNestedChildrenUpdateInput
}

# Filters the \\"Category\\" nodes by specifying some conditions
input CategoryWhereInput {
  _id: Int
  _id_not: Int
  _id_in: [Int!]
  _id_not_in: [Int!]
  _id_lt: Int
  _id_lte: Int
  _id_gt: Int
  _id_gte: Int
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  parent: CategoryWhereInput
  parent_is_null: Boolean
  articles_some: ArticleWhereInput
  children_some: CategoryWhereInput
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: CategoryWhereInput
}

# Identifies exactly one \\"Category\\" node with one of these unique combinations of values:
# - _id
# - id
# - parent, slug
input CategoryWhereUniqueInput {
  _id: Int
  id: ID
  parent: CategoryWhereUniqueInput
  slug: String
}

input CategoryWithForcedParentCreateInput {
  # The public ID
  id: ID
  title: String!

  # The category's slug
  slug: String

  # Actions for the \\"Category.articles\\" relation: \\"Article.category\\"'s inverse relation
  articles: CategoryNestedArticlesCreateInput

  # Actions for the \\"Category.children\\" relation: \\"Category.parent\\"'s inverse relation
  children: CategoryNestedChildrenCreateInput
}

input CategoryWithForcedParentUpdateInput {
  # The public ID
  id: ID
  title: String

  # Actions for the \\"Category.articles\\" relation: \\"Article.category\\"'s inverse relation
  articles: CategoryNestedArticlesUpdateInput

  # Actions for the \\"Category.children\\" relation: \\"Category.parent\\"'s inverse relation
  children: CategoryNestedChildrenUpdateInput
}

# Given a forced \\"parent\\", identifies exactly one \\"Category\\" node.
input CategoryWithForcedParentWhereUniqueInput {
  slug: String!
}

# Given a known \\"parent\\", identifies exactly one \\"Category\\" node with one of these unique combinations of values:
# - _id
# - id
# - parent (optional), slug
input CategoryWithOptionalParentWhereUniqueInput {
  _id: Int
  id: ID
  parent: CategoryWhereUniqueInput
  slug: String
}

# A date string, such as 2007-12-03, compliant with the \`full-date\` format
# outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for
# representation of dates and times using the Gregorian calendar.
scalar Date

# A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
# \`date-time\` format outlined in section 5.6 of the RFC 3339 profile of the ISO
# 8601 standard for representation of dates and times using the Gregorian calendar.
scalar DateTime

type Mutation {
  # Create a single \\"Article\\" node.
  createArticle(data: ArticleCreateInput!): Article!

  # Delete a single \\"Article\\" node.
  deleteArticle(where: ArticleWhereUniqueInput!): Article

  # Update a single \\"Article\\" node.
  updateArticle(where: ArticleWhereUniqueInput!, data: ArticleUpdateInput!): Article

  # Update or create a single \\"Article\\" node.
  upsertArticle(where: ArticleWhereUniqueInput!, update: ArticleUpdateInput!, create: ArticleCreateInput!): Article!

  # Create a single \\"ArticleTag\\" node.
  createArticleTag(data: ArticleTagCreateInput!): ArticleTag!

  # Delete a single \\"ArticleTag\\" node.
  deleteArticleTag(where: ArticleTagWhereUniqueInput!): ArticleTag

  # Update a single \\"ArticleTag\\" node.
  updateArticleTag(where: ArticleTagWhereUniqueInput!, data: ArticleTagUpdateInput!): ArticleTag

  # Update or create a single \\"ArticleTag\\" node.
  upsertArticleTag(where: ArticleTagWhereUniqueInput!, update: ArticleTagUpdateInput!, create: ArticleTagCreateInput!): ArticleTag!

  # Create a single \\"ArticleTagComment\\" node.
  createArticleTagComment(data: ArticleTagCommentCreateInput!): ArticleTagComment!

  # Delete a single \\"ArticleTagComment\\" node.
  deleteArticleTagComment(where: ArticleTagCommentWhereUniqueInput!): ArticleTagComment

  # Update a single \\"ArticleTagComment\\" node.
  updateArticleTagComment(where: ArticleTagCommentWhereUniqueInput!, data: ArticleTagCommentUpdateInput!): ArticleTagComment

  # Update or create a single \\"ArticleTagComment\\" node.
  upsertArticleTagComment(where: ArticleTagCommentWhereUniqueInput!, update: ArticleTagCommentUpdateInput!, create: ArticleTagCommentCreateInput!): ArticleTagComment!

  # Create a single \\"ArticleUrl\\" node.
  createArticleUrl(data: ArticleUrlCreateInput!): ArticleUrl!

  # Delete a single \\"ArticleUrl\\" node.
  deleteArticleUrl(where: ArticleUrlWhereUniqueInput!): ArticleUrl

  # Update a single \\"ArticleUrl\\" node.
  updateArticleUrl(where: ArticleUrlWhereUniqueInput!, data: ArticleUrlUpdateInput!): ArticleUrl

  # Update or create a single \\"ArticleUrl\\" node.
  upsertArticleUrl(where: ArticleUrlWhereUniqueInput!, update: ArticleUrlUpdateInput!, create: ArticleUrlCreateInput!): ArticleUrl!

  # Create a single \\"ArticleUrlMeta\\" node.
  createArticleUrlMeta(data: ArticleUrlMetaCreateInput!): ArticleUrlMeta!

  # Delete a single \\"ArticleUrlMeta\\" node.
  deleteArticleUrlMeta(where: ArticleUrlMetaWhereUniqueInput!): ArticleUrlMeta

  # Update a single \\"ArticleUrlMeta\\" node.
  updateArticleUrlMeta(where: ArticleUrlMetaWhereUniqueInput!, data: Boolean!): ArticleUrlMeta

  # Update or create a single \\"ArticleUrlMeta\\" node.
  upsertArticleUrlMeta(where: ArticleUrlMetaWhereUniqueInput!, update: Boolean!, create: ArticleUrlMetaCreateInput!): ArticleUrlMeta!

  # Create a single \\"Category\\" node.
  createCategory(data: CategoryCreateInput!): Category!

  # Delete a single \\"Category\\" node.
  deleteCategory(where: CategoryWhereUniqueInput!): Category

  # Update a single \\"Category\\" node.
  updateCategory(where: CategoryWhereUniqueInput!, data: CategoryUpdateInput!): Category

  # Update or create a single \\"Category\\" node.
  upsertCategory(where: CategoryWhereUniqueInput!, update: CategoryUpdateInput!, create: CategoryCreateInput!): Category!

  # Create a single \\"Tag\\" node.
  createTag(data: TagCreateInput!): Tag!

  # Create a single \\"User\\" node.
  createUser(data: UserCreateInput!): User!

  # Delete a single \\"User\\" node.
  deleteUser(where: UserWhereUniqueInput!): User

  # Update a single \\"User\\" node.
  updateUser(where: UserWhereUniqueInput!, data: UserUpdateInput!): User

  # Update or create a single \\"User\\" node.
  upsertUser(where: UserWhereUniqueInput!, update: UserUpdateInput!, create: UserCreateInput!): User!

  # Returns a JWT in case of success.
  login(login: String!, password: String!): String
}

type Query {
  # Retrieve the number of \\"Article\\" nodes.
  articleCount(where: ArticleWhereInput): Int!

  # Retrieve a list of \\"Article\\" nodes.
  articles(where: ArticleWhereInput, orderBy: [ArticleOrderByInput!], first: Int!, skip: Int): [Article!]!

  # Retrieve a single \\"Article\\" node.
  article(where: ArticleWhereUniqueInput!): Article

  # Retrieve the number of \\"ArticleTag\\" nodes.
  articleTagCount(where: ArticleTagWhereInput): Int!

  # Retrieve a list of \\"ArticleTag\\" nodes.
  articleTags(where: ArticleTagWhereInput, orderBy: [ArticleTagOrderByInput!], first: Int!, skip: Int): [ArticleTag!]!

  # Retrieve a single \\"ArticleTag\\" node.
  articleTag(where: ArticleTagWhereUniqueInput!): ArticleTag

  # Retrieve the number of \\"ArticleTagComment\\" nodes.
  articleTagCommentCount(where: ArticleTagCommentWhereInput): Int!

  # Retrieve a list of \\"ArticleTagComment\\" nodes.
  articleTagComments(where: ArticleTagCommentWhereInput, orderBy: [ArticleTagCommentOrderByInput!], first: Int!, skip: Int): [ArticleTagComment!]!

  # Retrieve a single \\"ArticleTagComment\\" node.
  articleTagComment(where: ArticleTagCommentWhereUniqueInput!): ArticleTagComment

  # Retrieve the number of \\"ArticleUrl\\" nodes.
  articleUrlCount(where: ArticleUrlWhereInput): Int!

  # Retrieve a list of \\"ArticleUrl\\" nodes.
  articleUrls(where: ArticleUrlWhereInput, orderBy: [ArticleUrlOrderByInput!], first: Int!, skip: Int): [ArticleUrl!]!

  # Retrieve a single \\"ArticleUrl\\" node.
  articleUrl(where: ArticleUrlWhereUniqueInput!): ArticleUrl

  # Retrieve the number of \\"ArticleUrlMeta\\" nodes.
  articleUrlMetaCount(where: ArticleUrlMetaWhereInput): Int!

  # Retrieve a list of \\"ArticleUrlMeta\\" nodes.
  articleUrlMetas(where: ArticleUrlMetaWhereInput, orderBy: [ArticleUrlMetaOrderByInput!], first: Int!, skip: Int): [ArticleUrlMeta!]!

  # Retrieve a single \\"ArticleUrlMeta\\" node.
  articleUrlMeta(where: ArticleUrlMetaWhereUniqueInput!): ArticleUrlMeta

  # Retrieve the number of \\"Category\\" nodes.
  categoryCount(where: CategoryWhereInput): Int!

  # Retrieve a list of \\"Category\\" nodes.
  categories(where: CategoryWhereInput, orderBy: [CategoryOrderByInput!], first: Int!, skip: Int): [Category!]!

  # Retrieve a single \\"Category\\" node.
  category(where: CategoryWhereUniqueInput!): Category

  # Retrieve the number of \\"Tag\\" nodes.
  tagCount(where: TagWhereInput): Int!

  # Retrieve a list of \\"Tag\\" nodes.
  tags(where: TagWhereInput, orderBy: [TagOrderByInput!], first: Int!, skip: Int): [Tag!]!

  # Retrieve a single \\"Tag\\" node.
  tag(where: TagWhereUniqueInput!): Tag

  # Retrieve the number of \\"User\\" nodes.
  userCount(where: UserWhereInput): Int!

  # Retrieve a list of \\"User\\" nodes.
  users(where: UserWhereInput, orderBy: [UserOrderByInput!], first: Int!, skip: Int): [User!]!

  # Retrieve a single \\"User\\" node.
  user(where: UserWhereUniqueInput!): User

  # A custom query.
  hello(name: String!, id: UserWhereUniqueInput!): User
}

# \\"Tag\\" resource's node
type Tag {
  # The public ID
  id: ID!

  # The date, fixed, of the document's creation
  createdAt: DateTime!

  # The date of the document's last update
  updatedAt: DateTime!
  title: String!

  # The tag's slug
  slug: String!

  # \\"ArticleTag.tag\\"'s inverse relation
  articles(where: ArticleTagWhereInput, orderBy: [ArticleTagOrderByInput!], first: Int!, skip: Int): [ArticleTag!]!

  # \\"ArticleTag.tag\\"'s inverse relation count
  articleCount(where: ArticleTagWhereInput): Int!
}

input TagCreateInput {
  # The public ID
  id: ID
  title: String!

  # The tag's slug
  slug: String

  # Actions for the \\"Tag.articles\\" relation: \\"ArticleTag.tag\\"'s inverse relation
  articles: TagNestedArticlesCreateInput
}

input TagNestedArticlesCreateInput {
  # Create new \\"ArticleTag\\" nodes and connect them to the new \\"Tag\\" node, through the \\"Tag.articles\\" relation.
  create: [ArticleTagWithForcedTagCreateInput!]
}

enum TagOrderByInput {
  _id_ASC
  _id_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
  slug_ASC
  slug_DESC
}

# Filters the \\"Tag\\" nodes by specifying some conditions
input TagWhereInput {
  _id: Int
  _id_not: Int
  _id_in: [Int!]
  _id_not_in: [Int!]
  _id_lt: Int
  _id_lte: Int
  _id_gt: Int
  _id_gte: Int
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  articles_some: ArticleTagWhereInput
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  NOT: TagWhereInput
}

# Identifies exactly one \\"Tag\\" node with one of these unique values:
# - _id
# - id
# - slug
input TagWhereUniqueInput {
  _id: Int
  id: ID
  slug: String
}

# A time string at UTC, such as 10:15:30Z, compliant with the \`full-time\` format
# outlined in section 5.6 of the RFC 3339profile of the ISO 8601 standard for
# representation of dates and times using the Gregorian calendar.
scalar Time

# \\"User\\" resource's node
type User {
  # The public ID
  id: ID!

  # The date, fixed, of the document's creation
  createdAt: DateTime!

  # The date of the document's last update
  updatedAt: DateTime!

  # The user's username
  username: String!

  # \\"Article.author\\"'s inverse relation
  authorOfArticles(where: ArticleWhereInput, orderBy: [ArticleOrderByInput!], first: Int!, skip: Int): [Article!]!

  # \\"Article.author\\"'s inverse relation count
  authorOfArticleCount(where: ArticleWhereInput): Int!

  # \\"Article.moderator\\"'s inverse relation
  moderatorOfArticles(where: ArticleWhereInput, orderBy: [ArticleOrderByInput!], first: Int!, skip: Int): [Article!]!

  # \\"Article.moderator\\"'s inverse relation count
  moderatorOfArticleCount(where: ArticleWhereInput): Int!
}

input UserCreateInput {
  # The public ID
  id: ID

  # The user's username
  username: String!

  # Actions for the \\"User.authorOfArticles\\" relation: \\"Article.author\\"'s inverse relation
  authorOfArticles: UserNestedAuthorOfArticlesCreateInput

  # Actions for the \\"User.moderatorOfArticles\\" relation: \\"Article.moderator\\"'s inverse relation
  moderatorOfArticles: UserNestedModeratorOfArticlesCreateInput
}

input UserNestedAuthorOfArticlesCreateInput {
  # Connect existing \\"Article\\" nodes to the new \\"User\\" node, through the \\"User.authorOfArticles\\" relation.
  connect: [ArticleWhereUniqueInput!]

  # Create new \\"Article\\" nodes and connect them to the new \\"User\\" node, through the \\"User.authorOfArticles\\" relation.
  create: [ArticleWithForcedAuthorCreateInput!]
}

input UserNestedAuthorOfArticlesUpdateInput {
  # Connect existing \\"Article\\" nodes to the existing \\"User\\" node, through the \\"User.authorOfArticles\\" relation.
  connect: [ArticleWhereUniqueInput!]

  # Update existing \\"Article\\" nodes and connect them to the existing \\"User\\" node,
  # through the \\"User.authorOfArticles\\" relation.
  update: [UserNestedUpdateAuthorOfArticlesUpdateInput!]

  # Create new \\"Article\\" nodes and connect them to the existing \\"User\\" node, through the \\"User.authorOfArticles\\" relation.
  create: [ArticleWithForcedAuthorCreateInput!]

  # Upsert existing \\"Article\\" nodes and connect them to the existing \\"User\\" node,
  # through the \\"User.authorOfArticles\\" relation.
  upsert: [UserNestedUpsertAuthorOfArticlesUpdateInput!]

  # Delete existing \\"Article\\" nodes from the \\"User.authorOfArticles\\" relation.
  delete: [ArticleWhereUniqueInput!]
}

input UserNestedModeratorOfArticlesCreateInput {
  # Connect existing \\"Article\\" nodes to the new \\"User\\" node, through the \\"User.moderatorOfArticles\\" relation.
  connect: [ArticleWhereUniqueInput!]

  # Create new \\"Article\\" nodes and connect them to the new \\"User\\" node, through the \\"User.moderatorOfArticles\\" relation.
  create: [ArticleWithForcedModeratorCreateInput!]
}

input UserNestedModeratorOfArticlesUpdateInput {
  # Connect existing \\"Article\\" nodes to the existing \\"User\\" node, through the \\"User.moderatorOfArticles\\" relation.
  connect: [ArticleWhereUniqueInput!]

  # Disconnect existing \\"Article\\" nodes of the \\"User.moderatorOfArticles\\" relation.
  disconnect: [ArticleWhereUniqueInput!]

  # Update existing \\"Article\\" nodes and connect them to the existing \\"User\\" node,
  # through the \\"User.moderatorOfArticles\\" relation.
  update: [UserNestedUpdateModeratorOfArticlesUpdateInput!]

  # Create new \\"Article\\" nodes and connect them to the existing \\"User\\" node, through the \\"User.moderatorOfArticles\\" relation.
  create: [ArticleWithForcedModeratorCreateInput!]

  # Upsert existing \\"Article\\" nodes and connect them to the existing \\"User\\" node,
  # through the \\"User.moderatorOfArticles\\" relation.
  upsert: [UserNestedUpsertModeratorOfArticlesUpdateInput!]

  # Delete existing \\"Article\\" nodes from the \\"User.moderatorOfArticles\\" relation.
  delete: [ArticleWhereUniqueInput!]
}

input UserNestedUpdateAuthorOfArticlesUpdateInput {
  where: ArticleWhereUniqueInput!
  data: ArticleWithForcedAuthorUpdateInput!
}

input UserNestedUpdateModeratorOfArticlesUpdateInput {
  where: ArticleWhereUniqueInput!
  data: ArticleWithForcedModeratorUpdateInput!
}

input UserNestedUpsertAuthorOfArticlesUpdateInput {
  where: ArticleWhereUniqueInput!
  update: ArticleWithForcedAuthorUpdateInput!
  create: ArticleWithForcedAuthorCreateInput!
}

input UserNestedUpsertModeratorOfArticlesUpdateInput {
  where: ArticleWhereUniqueInput!
  update: ArticleWithForcedModeratorUpdateInput!
  create: ArticleWithForcedModeratorCreateInput!
}

enum UserOrderByInput {
  _id_ASC
  _id_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  username_ASC
  username_DESC
}

input UserUpdateInput {
  # The public ID
  id: ID

  # Actions for the \\"User.authorOfArticles\\" relation: \\"Article.author\\"'s inverse relation
  authorOfArticles: UserNestedAuthorOfArticlesUpdateInput

  # Actions for the \\"User.moderatorOfArticles\\" relation: \\"Article.moderator\\"'s inverse relation
  moderatorOfArticles: UserNestedModeratorOfArticlesUpdateInput
}

# Filters the \\"User\\" nodes by specifying some conditions
input UserWhereInput {
  _id: Int
  _id_not: Int
  _id_in: [Int!]
  _id_not_in: [Int!]
  _id_lt: Int
  _id_lte: Int
  _id_gt: Int
  _id_gte: Int
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  authorOfArticles_some: ArticleWhereInput
  moderatorOfArticles_some: ArticleWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: UserWhereInput
}

# Identifies exactly one \\"User\\" node with one of these unique values:
# - _id
# - id
# - username
input UserWhereUniqueInput {
  _id: Int
  id: ID
  username: String
}
"
`;
