// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`GraphQLSchema creates a consistent valid GraphQL schema 1`] = `
"# \\"Article\\" resource's node
type Article {
  # The public ID
  id: ID!

  # The date, fixed, of the document's creation
  createdAt: DateTime!

  # The date of the document's last update
  updatedAt: DateTime!
  format: ArticleFormat!

  # The article's title
  title: String!

  # The article's slug
  slug: String!

  # The article's body
  body: String

  # The date of the document's public release
  publishedAt: DateTime

  # Either this article is published or not
  isPublished: Boolean!

  # Either this article is important or not
  isImportant: Boolean
  category: Category!
  author: User!
  moderator: User

  # \\"ArticleTag.article\\"'s inverse relation
  tags(where: ArticleTagWhereInput, orderBy: [ArticleTagOrderByInput!], first: Int!, skip: Int): [ArticleTag!]!

  # \\"ArticleTag.article\\"'s inverse relation count
  tagCount(where: ArticleTagWhereInput): Int!

  # \\"ArticleUrl.article\\"'s inverse relation
  url: ArticleUrl

  # Exemple of virtual field dependant of the field \\"title\\".
  lowerCasedTitle: String!
}

input ArticleCreateAuthorInput {
  # Connect an existing \\"User\\" node to the new \\"Article\\" node, through the \\"Article.author\\" relation.
  connect: UserWhereUniqueInput

  # Update an existing \\"User\\" node and connect it to the new \\"Article\\" node, through the \\"Article.author\\" relation.
  update: ArticleCreateNestedUpdateAuthorInput

  # Create a new \\"User\\" node and connect it to the new \\"Article\\" node, through the \\"Article.author\\" relation.
  create: UserCreateInput

  # Create or update a \\"User\\" node and connect it to the new \\"Article\\" node, through the \\"Article.author\\" relation.
  upsert: ArticleCreateNestedUpsertAuthorInput
}

input ArticleCreateCategoryInput {
  # Connect an existing \\"Category\\" node to the new \\"Article\\" node, through the \\"Article.category\\" relation.
  connect: CategoryWhereUniqueInput

  # Update an existing \\"Category\\" node and connect it to the new \\"Article\\" node, through the \\"Article.category\\" relation.
  update: ArticleCreateNestedUpdateCategoryInput

  # Create a new \\"Category\\" node and connect it to the new \\"Article\\" node, through the \\"Article.category\\" relation.
  create: CategoryCreateInput

  # Create or update a \\"Category\\" node and connect it to the new \\"Article\\" node, through the \\"Article.category\\" relation.
  upsert: ArticleCreateNestedUpsertCategoryInput
}

input ArticleCreateInput {
  # The public ID
  id: ID
  format: ArticleFormat!

  # The article's title
  title: String!

  # The article's slug
  slug: String

  # The article's body
  body: String

  # The date of the document's public release
  publishedAt: DateTime

  # Either this article is important or not
  isImportant: Boolean

  # Nested actions for the \\"Article.category\\" relation
  category: ArticleCreateCategoryInput!

  # Nested actions for the \\"Article.author\\" relation
  author: ArticleCreateAuthorInput!

  # Nested actions for the \\"Article.moderator\\" relation
  moderator: ArticleCreateModeratorInput

  # Nested actions for the \\"Article.tags\\" relation
  tags: ArticleCreateTagsInput

  # Nested actions for the \\"Article.url\\" relation
  url: ArticleCreateUrlInput
}

input ArticleCreateModeratorInput {
  # Connect an existing \\"User\\" node to the new \\"Article\\" node, through the \\"Article.moderator\\" relation.
  connect: UserWhereUniqueInput

  # Update an existing \\"User\\" node and connect it to the new \\"Article\\" node, through the \\"Article.moderator\\" relation.
  update: ArticleCreateNestedUpdateModeratorInput

  # Create a new \\"User\\" node and connect it to the new \\"Article\\" node, through the \\"Article.moderator\\" relation.
  create: UserCreateInput

  # Create or update a \\"User\\" node and connect it to the new \\"Article\\" node, through the \\"Article.moderator\\" relation.
  upsert: ArticleCreateNestedUpsertModeratorInput
}

input ArticleCreateNestedUpdateAuthorInput {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input ArticleCreateNestedUpdateCategoryInput {
  where: CategoryWhereUniqueInput!
  data: CategoryUpdateInput!
}

input ArticleCreateNestedUpdateModeratorInput {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input ArticleCreateNestedUpsertAuthorInput {
  where: UserWhereUniqueInput!
  create: UserCreateInput!
  update: UserUpdateInput!
}

input ArticleCreateNestedUpsertCategoryInput {
  where: CategoryWhereUniqueInput!
  create: CategoryCreateInput!
  update: CategoryUpdateInput!
}

input ArticleCreateNestedUpsertModeratorInput {
  where: UserWhereUniqueInput!
  create: UserCreateInput!
  update: UserUpdateInput!
}

input ArticleCreateTagsInput {
  # Create new \\"ArticleTag\\" nodes and connect them to the new \\"Article\\" node, through the \\"Article.tags\\" relation.
  create: [ArticleTagWithForcedArticleCreateInput!]
}

input ArticleCreateUrlInput {
  # Create a new \\"ArticleUrl\\" node and connect it to the new \\"Article\\" node, through the \\"Article.url\\" relation.
  create: ArticleUrlWithForcedArticleCreateInput
}

enum ArticleFormat {
  Rich
  Video
}

enum ArticleOrderByInput {
  _id_ASC
  _id_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  format_ASC
  format_DESC
  title_ASC
  title_DESC
  slug_ASC
  slug_DESC
  body_ASC
  body_DESC
  publishedAt_ASC
  publishedAt_DESC
  isPublished_ASC
  isPublished_DESC
  isImportant_ASC
  isImportant_DESC
}

# \\"ArticleTag\\" resource's node
type ArticleTag {
  # The date, fixed, of the document's creation
  createdAt: DateTime!

  # The date of the document's last update
  updatedAt: DateTime!
  order: Int!
  article: Article!
  tag: Tag!

  # \\"ArticleTagComment.articleTag\\"'s inverse relation
  comment: ArticleTagComment
}

# \\"ArticleTagComment\\" resource's node
type ArticleTagComment {
  # The date, fixed, of the document's creation
  createdAt: DateTime!

  # The date of the document's last update
  updatedAt: DateTime!
  body: String
  articleTag: ArticleTag!
}

input ArticleTagCommentCreateArticleTagInput {
  # Connect an existing \\"ArticleTag\\" node to the new \\"ArticleTagComment\\" node,
  # through the \\"ArticleTagComment.articleTag\\" relation.
  connect: ArticleTagWhereUniqueInput

  # Update an existing \\"ArticleTag\\" node and connect it to the new
  # \\"ArticleTagComment\\" node, through the \\"ArticleTagComment.articleTag\\" relation.
  update: ArticleTagCommentCreateNestedUpdateArticleTagInput

  # Create a new \\"ArticleTag\\" node and connect it to the new \\"ArticleTagComment\\"
  # node, through the \\"ArticleTagComment.articleTag\\" relation.
  create: ArticleTagCreateInput

  # Create or update a \\"ArticleTag\\" node and connect it to the new
  # \\"ArticleTagComment\\" node, through the \\"ArticleTagComment.articleTag\\" relation.
  upsert: ArticleTagCommentCreateNestedUpsertArticleTagInput
}

input ArticleTagCommentCreateInput {
  body: String

  # Nested actions for the \\"ArticleTagComment.articleTag\\" relation
  articleTag: ArticleTagCommentCreateArticleTagInput!
}

input ArticleTagCommentCreateNestedUpdateArticleTagInput {
  where: ArticleTagWhereUniqueInput!
  data: ArticleTagUpdateInput!
}

input ArticleTagCommentCreateNestedUpsertArticleTagInput {
  where: ArticleTagWhereUniqueInput!
  create: ArticleTagCreateInput!
  update: ArticleTagUpdateInput!
}

enum ArticleTagCommentOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  body_ASC
  body_DESC
}

input ArticleTagCommentUpdateInput {
  body: String
}

# Filters the \\"ArticleTagComment\\" nodes by specifying some conditions
input ArticleTagCommentWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime]
  createdAt_not_in: [DateTime]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime]
  updatedAt_not_in: [DateTime]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  body: String
  body_not: String
  body_in: [String]
  body_not_in: [String]
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  articleTag: ArticleTagWhereInput
  AND: [ArticleTagCommentWhereInput!]
  OR: [ArticleTagCommentWhereInput!]
  NOT: ArticleTagCommentWhereInput
}

# Identifies exactly one \\"ArticleTagComment\\" node.
input ArticleTagCommentWhereUniqueInput {
  articleTag: ArticleTagWhereUniqueInput!
}

input ArticleTagCommentWithForcedArticleTagCreateInput {
  body: String
}

input ArticleTagCommentWithForcedArticleTagUpdateInput {
  body: String
}

# Given a known \\"articleTag\\", identifies exactly one \\"ArticleTagComment\\" node.
input ArticleTagCommentWithOptionalArticleTagWhereUniqueInput {
  articleTag: ArticleTagWhereUniqueInput
}

input ArticleTagCreateArticleInput {
  # Connect an existing \\"Article\\" node to the new \\"ArticleTag\\" node, through the \\"ArticleTag.article\\" relation.
  connect: ArticleWhereUniqueInput

  # Update an existing \\"Article\\" node and connect it to the new \\"ArticleTag\\" node, through the \\"ArticleTag.article\\" relation.
  update: ArticleTagCreateNestedUpdateArticleInput

  # Create a new \\"Article\\" node and connect it to the new \\"ArticleTag\\" node, through the \\"ArticleTag.article\\" relation.
  create: ArticleCreateInput

  # Create or update a \\"Article\\" node and connect it to the new \\"ArticleTag\\" node, through the \\"ArticleTag.article\\" relation.
  upsert: ArticleTagCreateNestedUpsertArticleInput
}

input ArticleTagCreateCommentInput {
  # Create a new \\"ArticleTagComment\\" node and connect it to the new \\"ArticleTag\\"
  # node, through the \\"ArticleTag.comment\\" relation.
  create: ArticleTagCommentWithForcedArticleTagCreateInput
}

input ArticleTagCreateInput {
  order: Int!

  # Nested actions for the \\"ArticleTag.article\\" relation
  article: ArticleTagCreateArticleInput!

  # Nested actions for the \\"ArticleTag.tag\\" relation
  tag: ArticleTagCreateTagInput!

  # Nested actions for the \\"ArticleTag.comment\\" relation
  comment: ArticleTagCreateCommentInput
}

input ArticleTagCreateNestedUpdateArticleInput {
  where: ArticleWhereUniqueInput!
  data: ArticleUpdateInput!
}

input ArticleTagCreateNestedUpsertArticleInput {
  where: ArticleWhereUniqueInput!
  create: ArticleCreateInput!
  update: ArticleUpdateInput!
}

input ArticleTagCreateTagInput {
  # Connect an existing \\"Tag\\" node to the new \\"ArticleTag\\" node, through the \\"ArticleTag.tag\\" relation.
  connect: TagWhereUniqueInput

  # Create a new \\"Tag\\" node and connect it to the new \\"ArticleTag\\" node, through the \\"ArticleTag.tag\\" relation.
  create: TagCreateInput
}

enum ArticleTagOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  order_ASC
  order_DESC
}

input ArticleTagUpdateCommentInput {
  # Update an existing \\"ArticleTagComment\\" node and connect it to the existing
  # \\"ArticleTag\\" node, through the \\"ArticleTag.comment\\" relation.
  update: ArticleTagUpdateNestedUpdateCommentInput

  # Create a new \\"ArticleTagComment\\" node and connect it to the existing
  # \\"ArticleTag\\" node, through the \\"ArticleTag.comment\\" relation.
  create: ArticleTagCommentWithForcedArticleTagCreateInput

  # Upsert an existing \\"ArticleTagComment\\" node and connect it to the existing
  # \\"ArticleTag\\" node, through the \\"ArticleTag.comment\\" relation.
  upsert: ArticleTagUpdateNestedUpsertCommentInput

  # Delete an existing \\"ArticleTagComment\\" node from the \\"ArticleTag.comment\\" relation.
  delete: Boolean
}

input ArticleTagUpdateInput {
  order: Int

  # Nested actions for the \\"ArticleTag.comment\\" relation
  comment: ArticleTagUpdateCommentInput
}

input ArticleTagUpdateNestedUpdateCommentInput {
  where: ArticleTagCommentWithOptionalArticleTagWhereUniqueInput
  data: ArticleTagCommentWithForcedArticleTagUpdateInput!
}

input ArticleTagUpdateNestedUpsertCommentInput {
  where: ArticleTagCommentWithOptionalArticleTagWhereUniqueInput!
  update: ArticleTagCommentWithForcedArticleTagUpdateInput!
  create: ArticleTagCommentWithForcedArticleTagCreateInput!
}

# Filters the \\"ArticleTag\\" nodes by specifying some conditions
input ArticleTagWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime]
  createdAt_not_in: [DateTime]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime]
  updatedAt_not_in: [DateTime]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  order: Int
  order_not: Int
  order_in: [Int]
  order_not_in: [Int]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  article: ArticleWhereInput
  tag: TagWhereInput
  comment: ArticleTagCommentWhereInput
  comment_is_null: Boolean
  AND: [ArticleTagWhereInput!]
  OR: [ArticleTagWhereInput!]
  NOT: ArticleTagWhereInput
}

# Identifies exactly one \\"ArticleTag\\" node with one of these unique combinations of values:
# - article, tag
# - article, order
input ArticleTagWhereUniqueInput {
  article: ArticleWhereUniqueInput!
  tag: TagWhereUniqueInput
  order: Int
}

input ArticleTagWithForcedArticleCreateInput {
  order: Int!

  # Nested actions for the \\"ArticleTag.tag\\" relation
  tag: ArticleTagCreateTagInput!

  # Nested actions for the \\"ArticleTag.comment\\" relation
  comment: ArticleTagCreateCommentInput
}

input ArticleTagWithForcedArticleUpdateInput {
  order: Int

  # Nested actions for the \\"ArticleTag.comment\\" relation
  comment: ArticleTagUpdateCommentInput
}

# Given a forced \\"article\\", identifies exactly one \\"ArticleTag\\" node with one of these unique values:
# - tag
# - order
input ArticleTagWithForcedArticleWhereUniqueInput {
  tag: TagWhereUniqueInput
  order: Int
}

input ArticleTagWithForcedTagCreateInput {
  order: Int!

  # Nested actions for the \\"ArticleTag.article\\" relation
  article: ArticleTagCreateArticleInput!

  # Nested actions for the \\"ArticleTag.comment\\" relation
  comment: ArticleTagCreateCommentInput
}

# Given a known \\"article\\", identifies exactly one \\"ArticleTag\\" node with one of these unique combinations of values:
# - article (optional), tag
# - article (optional), order
input ArticleTagWithOptionalArticleWhereUniqueInput {
  article: ArticleWhereUniqueInput
  tag: TagWhereUniqueInput
  order: Int
}

input ArticleUpdateAuthorInput {
  # Connect an existing \\"User\\" node to the existing \\"Article\\" node, through the \\"Article.author\\" relation.
  connect: UserWhereUniqueInput

  # Update an existing \\"User\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.author\\" relation.
  update: ArticleUpdateNestedUpdateAuthorInput

  # Create a new \\"User\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.author\\" relation.
  create: UserCreateInput

  # Create or update a \\"User\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.author\\" relation.
  upsert: ArticleUpdateNestedUpsertAuthorInput
}

input ArticleUpdateCategoryInput {
  # Connect an existing \\"Category\\" node to the existing \\"Article\\" node, through the \\"Article.category\\" relation.
  connect: CategoryWhereUniqueInput

  # Update an existing \\"Category\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.category\\" relation.
  update: ArticleUpdateNestedUpdateCategoryInput

  # Create a new \\"Category\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.category\\" relation.
  create: CategoryCreateInput

  # Create or update a \\"Category\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.category\\" relation.
  upsert: ArticleUpdateNestedUpsertCategoryInput
}

input ArticleUpdateInput {
  # The public ID
  id: ID
  format: ArticleFormat

  # The article's title
  title: String

  # The article's body
  body: String

  # The date of the document's public release
  publishedAt: DateTime

  # Either this article is important or not
  isImportant: Boolean

  # Nested actions for the \\"Article.category\\" relation
  category: ArticleUpdateCategoryInput

  # Nested actions for the \\"Article.author\\" relation
  author: ArticleUpdateAuthorInput

  # Nested actions for the \\"Article.moderator\\" relation
  moderator: ArticleUpdateModeratorInput

  # Nested actions for the \\"Article.tags\\" relation
  tags: ArticleUpdateTagsInput

  # Nested actions for the \\"Article.url\\" relation
  url: ArticleUpdateUrlInput
}

input ArticleUpdateModeratorInput {
  # Connect an existing \\"User\\" node to the existing \\"Article\\" node, through the \\"Article.moderator\\" relation.
  connect: UserWhereUniqueInput

  # Update an existing \\"User\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.moderator\\" relation.
  update: ArticleUpdateNestedUpdateModeratorInput

  # Create a new \\"User\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.moderator\\" relation.
  create: UserCreateInput

  # Create or update a \\"User\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.moderator\\" relation.
  upsert: ArticleUpdateNestedUpsertModeratorInput

  # Disconnect the current connected \\"User\\" node, if any, of the \\"Article.moderator\\" relation.
  disconnect: Boolean
}

input ArticleUpdateNestedUpdateAuthorInput {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input ArticleUpdateNestedUpdateCategoryInput {
  where: CategoryWhereUniqueInput!
  data: CategoryUpdateInput!
}

input ArticleUpdateNestedUpdateModeratorInput {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input ArticleUpdateNestedUpdateTagsInput {
  where: ArticleTagWithOptionalArticleWhereUniqueInput!
  data: ArticleTagWithForcedArticleUpdateInput!
}

input ArticleUpdateNestedUpdateUrlInput {
  where: ArticleUrlWithOptionalArticleWhereUniqueInput
  data: ArticleUrlWithForcedArticleUpdateInput!
}

input ArticleUpdateNestedUpsertAuthorInput {
  where: UserWhereUniqueInput!
  create: UserCreateInput!
  update: UserUpdateInput!
}

input ArticleUpdateNestedUpsertCategoryInput {
  where: CategoryWhereUniqueInput!
  create: CategoryCreateInput!
  update: CategoryUpdateInput!
}

input ArticleUpdateNestedUpsertModeratorInput {
  where: UserWhereUniqueInput!
  create: UserCreateInput!
  update: UserUpdateInput!
}

input ArticleUpdateNestedUpsertTagsInput {
  where: ArticleTagWithOptionalArticleWhereUniqueInput!
  update: ArticleTagWithForcedArticleUpdateInput!
  create: ArticleTagWithForcedArticleCreateInput!
}

input ArticleUpdateNestedUpsertUrlInput {
  where: ArticleUrlWithOptionalArticleWhereUniqueInput!
  update: ArticleUrlWithForcedArticleUpdateInput!
  create: ArticleUrlWithForcedArticleCreateInput!
}

input ArticleUpdateTagsInput {
  # Update existing \\"ArticleTag\\" nodes and connect them to the existing \\"Article\\" node, through the \\"Article.tags\\" relation.
  update: [ArticleUpdateNestedUpdateTagsInput!]

  # Create new \\"ArticleTag\\" nodes and connect them to the existing \\"Article\\" node, through the \\"Article.tags\\" relation.
  create: [ArticleTagWithForcedArticleCreateInput!]

  # Upsert existing \\"ArticleTag\\" nodes and connect them to the existing \\"Article\\" node, through the \\"Article.tags\\" relation.
  upsert: [ArticleUpdateNestedUpsertTagsInput!]

  # Delete existing \\"ArticleTag\\" nodes from the \\"Article.tags\\" relation.
  delete: [ArticleTagWithForcedArticleWhereUniqueInput!]
}

input ArticleUpdateUrlInput {
  # Update an existing \\"ArticleUrl\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.url\\" relation.
  update: ArticleUpdateNestedUpdateUrlInput

  # Create a new \\"ArticleUrl\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.url\\" relation.
  create: ArticleUrlWithForcedArticleCreateInput

  # Upsert an existing \\"ArticleUrl\\" node and connect it to the existing \\"Article\\" node, through the \\"Article.url\\" relation.
  upsert: ArticleUpdateNestedUpsertUrlInput

  # Delete an existing \\"ArticleUrl\\" node from the \\"Article.url\\" relation.
  delete: Boolean
}

# \\"ArticleUrl\\" resource's node
type ArticleUrl {
  # The date, fixed, of the document's creation
  createdAt: DateTime!

  # The date of the document's last update
  updatedAt: DateTime!
  path: String!
  article: Article!

  # \\"ArticleUrlMeta.url\\"'s inverse relation
  meta: ArticleUrlMeta
}

input ArticleUrlCreateArticleInput {
  # Connect an existing \\"Article\\" node to the new \\"ArticleUrl\\" node, through the \\"ArticleUrl.article\\" relation.
  connect: ArticleWhereUniqueInput

  # Update an existing \\"Article\\" node and connect it to the new \\"ArticleUrl\\" node, through the \\"ArticleUrl.article\\" relation.
  update: ArticleUrlCreateNestedUpdateArticleInput

  # Create a new \\"Article\\" node and connect it to the new \\"ArticleUrl\\" node, through the \\"ArticleUrl.article\\" relation.
  create: ArticleCreateInput

  # Create or update a \\"Article\\" node and connect it to the new \\"ArticleUrl\\" node, through the \\"ArticleUrl.article\\" relation.
  upsert: ArticleUrlCreateNestedUpsertArticleInput
}

input ArticleUrlCreateInput {
  path: String!

  # Nested actions for the \\"ArticleUrl.article\\" relation
  article: ArticleUrlCreateArticleInput!

  # Nested actions for the \\"ArticleUrl.meta\\" relation
  meta: ArticleUrlCreateMetaInput
}

input ArticleUrlCreateMetaInput {
  # Create a new \\"ArticleUrlMeta\\" node and connect it to the new \\"ArticleUrl\\" node, through the \\"ArticleUrl.meta\\" relation.
  create: Boolean
}

input ArticleUrlCreateNestedUpdateArticleInput {
  where: ArticleWhereUniqueInput!
  data: ArticleUpdateInput!
}

input ArticleUrlCreateNestedUpsertArticleInput {
  where: ArticleWhereUniqueInput!
  create: ArticleCreateInput!
  update: ArticleUpdateInput!
}

# \\"ArticleUrlMeta\\" resource's node
type ArticleUrlMeta {
  # The date, fixed, of the document's creation
  createdAt: DateTime!

  # The date of the document's last update
  updatedAt: DateTime!
  url: ArticleUrl!
}

input ArticleUrlMetaCreateInput {
  # Nested actions for the \\"ArticleUrlMeta.url\\" relation
  url: ArticleUrlMetaCreateUrlInput!
}

input ArticleUrlMetaCreateNestedUpdateUrlInput {
  where: ArticleUrlWhereUniqueInput!
  data: ArticleUrlUpdateInput!
}

input ArticleUrlMetaCreateNestedUpsertUrlInput {
  where: ArticleUrlWhereUniqueInput!
  create: ArticleUrlCreateInput!
  update: ArticleUrlUpdateInput!
}

input ArticleUrlMetaCreateUrlInput {
  # Connect an existing \\"ArticleUrl\\" node to the new \\"ArticleUrlMeta\\" node, through the \\"ArticleUrlMeta.url\\" relation.
  connect: ArticleUrlWhereUniqueInput

  # Update an existing \\"ArticleUrl\\" node and connect it to the new
  # \\"ArticleUrlMeta\\" node, through the \\"ArticleUrlMeta.url\\" relation.
  update: ArticleUrlMetaCreateNestedUpdateUrlInput

  # Create a new \\"ArticleUrl\\" node and connect it to the new \\"ArticleUrlMeta\\" node, through the \\"ArticleUrlMeta.url\\" relation.
  create: ArticleUrlCreateInput

  # Create or update a \\"ArticleUrl\\" node and connect it to the new
  # \\"ArticleUrlMeta\\" node, through the \\"ArticleUrlMeta.url\\" relation.
  upsert: ArticleUrlMetaCreateNestedUpsertUrlInput
}

enum ArticleUrlMetaOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

# Filters the \\"ArticleUrlMeta\\" nodes by specifying some conditions
input ArticleUrlMetaWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime]
  createdAt_not_in: [DateTime]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime]
  updatedAt_not_in: [DateTime]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  url: ArticleUrlWhereInput
  AND: [ArticleUrlMetaWhereInput!]
  OR: [ArticleUrlMetaWhereInput!]
  NOT: ArticleUrlMetaWhereInput
}

# Identifies exactly one \\"ArticleUrlMeta\\" node.
input ArticleUrlMetaWhereUniqueInput {
  url: ArticleUrlWhereUniqueInput!
}

# Given a known \\"url\\", identifies exactly one \\"ArticleUrlMeta\\" node.
input ArticleUrlMetaWithOptionalUrlWhereUniqueInput {
  url: ArticleUrlWhereUniqueInput
}

enum ArticleUrlOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  path_ASC
  path_DESC
}

input ArticleUrlUpdateInput {
  path: String

  # Nested actions for the \\"ArticleUrl.meta\\" relation
  meta: ArticleUrlUpdateMetaInput
}

input ArticleUrlUpdateMetaInput {
  # Update an existing \\"ArticleUrlMeta\\" node and connect it to the existing
  # \\"ArticleUrl\\" node, through the \\"ArticleUrl.meta\\" relation.
  update: ArticleUrlUpdateNestedUpdateMetaInput

  # Create a new \\"ArticleUrlMeta\\" node and connect it to the existing \\"ArticleUrl\\"
  # node, through the \\"ArticleUrl.meta\\" relation.
  create: Boolean

  # Upsert an existing \\"ArticleUrlMeta\\" node and connect it to the existing
  # \\"ArticleUrl\\" node, through the \\"ArticleUrl.meta\\" relation.
  upsert: ArticleUrlUpdateNestedUpsertMetaInput

  # Delete an existing \\"ArticleUrlMeta\\" node from the \\"ArticleUrl.meta\\" relation.
  delete: Boolean
}

input ArticleUrlUpdateNestedUpdateMetaInput {
  where: ArticleUrlMetaWithOptionalUrlWhereUniqueInput
  data: Boolean!
}

input ArticleUrlUpdateNestedUpsertMetaInput {
  where: ArticleUrlMetaWithOptionalUrlWhereUniqueInput!
  update: Boolean!
  create: Boolean!
}

# Filters the \\"ArticleUrl\\" nodes by specifying some conditions
input ArticleUrlWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime]
  createdAt_not_in: [DateTime]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime]
  updatedAt_not_in: [DateTime]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  path: String
  path_not: String
  path_in: [String]
  path_not_in: [String]
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  article: ArticleWhereInput
  meta: ArticleUrlMetaWhereInput
  meta_is_null: Boolean
  AND: [ArticleUrlWhereInput!]
  OR: [ArticleUrlWhereInput!]
  NOT: ArticleUrlWhereInput
}

# Identifies exactly one \\"ArticleUrl\\" node.
input ArticleUrlWhereUniqueInput {
  article: ArticleWhereUniqueInput!
}

input ArticleUrlWithForcedArticleCreateInput {
  path: String!

  # Nested actions for the \\"ArticleUrl.meta\\" relation
  meta: ArticleUrlCreateMetaInput
}

input ArticleUrlWithForcedArticleUpdateInput {
  path: String

  # Nested actions for the \\"ArticleUrl.meta\\" relation
  meta: ArticleUrlUpdateMetaInput
}

# Given a known \\"article\\", identifies exactly one \\"ArticleUrl\\" node.
input ArticleUrlWithOptionalArticleWhereUniqueInput {
  article: ArticleWhereUniqueInput
}

# Filters the \\"Article\\" nodes by specifying some conditions
input ArticleWhereInput {
  _id: Int
  _id_not: Int
  _id_in: [Int]
  _id_not_in: [Int]
  _id_lt: Int
  _id_lte: Int
  _id_gt: Int
  _id_gte: Int
  id: ID
  id_not: ID
  id_in: [ID]
  id_not_in: [ID]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime]
  createdAt_not_in: [DateTime]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime]
  updatedAt_not_in: [DateTime]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  format: ArticleFormat
  format_not: ArticleFormat
  format_in: [ArticleFormat]
  format_not_in: [ArticleFormat]
  title: String
  title_not: String
  title_in: [String]
  title_not_in: [String]
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  slug: String
  slug_not: String
  slug_in: [String]
  slug_not_in: [String]
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  body: String
  body_not: String
  body_in: [String]
  body_not_in: [String]
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  publishedAt: DateTime
  publishedAt_not: DateTime
  publishedAt_in: [DateTime]
  publishedAt_not_in: [DateTime]
  publishedAt_lt: DateTime
  publishedAt_lte: DateTime
  publishedAt_gt: DateTime
  publishedAt_gte: DateTime
  isPublished: Boolean
  isPublished_not: Boolean
  isPublished_in: [Boolean]
  isPublished_not_in: [Boolean]
  isImportant: Boolean
  isImportant_not: Boolean
  isImportant_in: [Boolean]
  isImportant_not_in: [Boolean]
  category: CategoryWhereInput
  author: UserWhereInput
  moderator: UserWhereInput
  moderator_is_null: Boolean
  tags_some: ArticleTagWhereInput
  url: ArticleUrlWhereInput
  url_is_null: Boolean
  AND: [ArticleWhereInput!]
  OR: [ArticleWhereInput!]
  NOT: ArticleWhereInput
}

# Identifies exactly one \\"Article\\" node with one of these unique combinations of values:
# - _id
# - id
# - category, slug
input ArticleWhereUniqueInput {
  _id: Int
  id: ID
  category: CategoryWhereUniqueInput
  slug: String
}

input ArticleWithForcedAuthorCreateInput {
  # The public ID
  id: ID
  format: ArticleFormat!

  # The article's title
  title: String!

  # The article's slug
  slug: String

  # The article's body
  body: String

  # The date of the document's public release
  publishedAt: DateTime

  # Either this article is important or not
  isImportant: Boolean

  # Nested actions for the \\"Article.category\\" relation
  category: ArticleCreateCategoryInput!

  # Nested actions for the \\"Article.moderator\\" relation
  moderator: ArticleCreateModeratorInput

  # Nested actions for the \\"Article.tags\\" relation
  tags: ArticleCreateTagsInput

  # Nested actions for the \\"Article.url\\" relation
  url: ArticleCreateUrlInput
}

input ArticleWithForcedAuthorUpdateInput {
  # The public ID
  id: ID
  format: ArticleFormat

  # The article's title
  title: String

  # The article's body
  body: String

  # The date of the document's public release
  publishedAt: DateTime

  # Either this article is important or not
  isImportant: Boolean

  # Nested actions for the \\"Article.category\\" relation
  category: ArticleUpdateCategoryInput

  # Nested actions for the \\"Article.moderator\\" relation
  moderator: ArticleUpdateModeratorInput

  # Nested actions for the \\"Article.tags\\" relation
  tags: ArticleUpdateTagsInput

  # Nested actions for the \\"Article.url\\" relation
  url: ArticleUpdateUrlInput
}

input ArticleWithForcedCategoryCreateInput {
  # The public ID
  id: ID
  format: ArticleFormat!

  # The article's title
  title: String!

  # The article's slug
  slug: String

  # The article's body
  body: String

  # The date of the document's public release
  publishedAt: DateTime

  # Either this article is important or not
  isImportant: Boolean

  # Nested actions for the \\"Article.author\\" relation
  author: ArticleCreateAuthorInput!

  # Nested actions for the \\"Article.moderator\\" relation
  moderator: ArticleCreateModeratorInput

  # Nested actions for the \\"Article.tags\\" relation
  tags: ArticleCreateTagsInput

  # Nested actions for the \\"Article.url\\" relation
  url: ArticleCreateUrlInput
}

input ArticleWithForcedCategoryUpdateInput {
  # The public ID
  id: ID
  format: ArticleFormat

  # The article's title
  title: String

  # The article's body
  body: String

  # The date of the document's public release
  publishedAt: DateTime

  # Either this article is important or not
  isImportant: Boolean

  # Nested actions for the \\"Article.author\\" relation
  author: ArticleUpdateAuthorInput

  # Nested actions for the \\"Article.moderator\\" relation
  moderator: ArticleUpdateModeratorInput

  # Nested actions for the \\"Article.tags\\" relation
  tags: ArticleUpdateTagsInput

  # Nested actions for the \\"Article.url\\" relation
  url: ArticleUpdateUrlInput
}

# Given a forced \\"category\\", identifies exactly one \\"Article\\" node.
input ArticleWithForcedCategoryWhereUniqueInput {
  slug: String!
}

input ArticleWithForcedModeratorCreateInput {
  # The public ID
  id: ID
  format: ArticleFormat!

  # The article's title
  title: String!

  # The article's slug
  slug: String

  # The article's body
  body: String

  # The date of the document's public release
  publishedAt: DateTime

  # Either this article is important or not
  isImportant: Boolean

  # Nested actions for the \\"Article.category\\" relation
  category: ArticleCreateCategoryInput!

  # Nested actions for the \\"Article.author\\" relation
  author: ArticleCreateAuthorInput!

  # Nested actions for the \\"Article.tags\\" relation
  tags: ArticleCreateTagsInput

  # Nested actions for the \\"Article.url\\" relation
  url: ArticleCreateUrlInput
}

input ArticleWithForcedModeratorUpdateInput {
  # The public ID
  id: ID
  format: ArticleFormat

  # The article's title
  title: String

  # The article's body
  body: String

  # The date of the document's public release
  publishedAt: DateTime

  # Either this article is important or not
  isImportant: Boolean

  # Nested actions for the \\"Article.category\\" relation
  category: ArticleUpdateCategoryInput

  # Nested actions for the \\"Article.author\\" relation
  author: ArticleUpdateAuthorInput

  # Nested actions for the \\"Article.tags\\" relation
  tags: ArticleUpdateTagsInput

  # Nested actions for the \\"Article.url\\" relation
  url: ArticleUpdateUrlInput
}

# Given a known \\"category\\", identifies exactly one \\"Article\\" node with one of these unique combinations of values:
# - _id
# - id
# - category (optional), slug
input ArticleWithOptionalCategoryWhereUniqueInput {
  _id: Int
  id: ID
  category: CategoryWhereUniqueInput
  slug: String
}

# \\"Category\\" resource's node
type Category {
  # The public ID
  id: ID!

  # The date, fixed, of the document's creation
  createdAt: DateTime!

  # The date of the document's last update
  updatedAt: DateTime!
  title: String!

  # The category's slug
  slug: String!
  parent: Category

  # \\"Article.category\\"'s inverse relation
  articles(where: ArticleWhereInput, orderBy: [ArticleOrderByInput!], first: Int!, skip: Int): [Article!]!

  # \\"Article.category\\"'s inverse relation count
  articleCount(where: ArticleWhereInput): Int!

  # \\"Category.parent\\"'s inverse relation
  children(where: CategoryWhereInput, orderBy: [CategoryOrderByInput!], first: Int!, skip: Int): [Category!]!

  # \\"Category.parent\\"'s inverse relation count
  childCount(where: CategoryWhereInput): Int!
}

input CategoryCreateArticlesInput {
  # Connect existing \\"Article\\" nodes to the new \\"Category\\" node, through the \\"Category.articles\\" relation.
  connect: [ArticleWhereUniqueInput!]

  # Create new \\"Article\\" nodes and connect them to the new \\"Category\\" node, through the \\"Category.articles\\" relation.
  create: [ArticleWithForcedCategoryCreateInput!]
}

input CategoryCreateChildrenInput {
  # Connect existing \\"Category\\" nodes to the new \\"Category\\" node, through the \\"Category.children\\" relation.
  connect: [CategoryWhereUniqueInput!]

  # Create new \\"Category\\" nodes and connect them to the new \\"Category\\" node, through the \\"Category.children\\" relation.
  create: [CategoryWithForcedParentCreateInput!]
}

input CategoryCreateInput {
  # The public ID
  id: ID
  title: String!

  # The category's slug
  slug: String

  # Nested actions for the \\"Category.parent\\" relation
  parent: CategoryCreateParentInput

  # Nested actions for the \\"Category.articles\\" relation
  articles: CategoryCreateArticlesInput

  # Nested actions for the \\"Category.children\\" relation
  children: CategoryCreateChildrenInput
}

input CategoryCreateNestedUpdateParentInput {
  where: CategoryWhereUniqueInput!
  data: CategoryUpdateInput!
}

input CategoryCreateNestedUpsertParentInput {
  where: CategoryWhereUniqueInput!
  create: CategoryCreateInput!
  update: CategoryUpdateInput!
}

input CategoryCreateParentInput {
  # Connect an existing \\"Category\\" node to the new \\"Category\\" node, through the \\"Category.parent\\" relation.
  connect: CategoryWhereUniqueInput

  # Update an existing \\"Category\\" node and connect it to the new \\"Category\\" node, through the \\"Category.parent\\" relation.
  update: CategoryCreateNestedUpdateParentInput

  # Create a new \\"Category\\" node and connect it to the new \\"Category\\" node, through the \\"Category.parent\\" relation.
  create: CategoryCreateInput

  # Create or update a \\"Category\\" node and connect it to the new \\"Category\\" node, through the \\"Category.parent\\" relation.
  upsert: CategoryCreateNestedUpsertParentInput
}

enum CategoryOrderByInput {
  _id_ASC
  _id_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
  slug_ASC
  slug_DESC
}

input CategoryUpdateArticlesInput {
  # Connect existing \\"Article\\" nodes to the existing \\"Category\\" node, through the \\"Category.articles\\" relation.
  connect: [ArticleWhereUniqueInput!]

  # Update existing \\"Article\\" nodes and connect them to the existing \\"Category\\"
  # node, through the \\"Category.articles\\" relation.
  update: [CategoryUpdateNestedUpdateArticlesInput!]

  # Create new \\"Article\\" nodes and connect them to the existing \\"Category\\" node, through the \\"Category.articles\\" relation.
  create: [ArticleWithForcedCategoryCreateInput!]

  # Upsert existing \\"Article\\" nodes and connect them to the existing \\"Category\\"
  # node, through the \\"Category.articles\\" relation.
  upsert: [CategoryUpdateNestedUpsertArticlesInput!]

  # Delete existing \\"Article\\" nodes from the \\"Category.articles\\" relation.
  delete: [ArticleWithForcedCategoryWhereUniqueInput!]
}

input CategoryUpdateChildrenInput {
  # Connect existing \\"Category\\" nodes to the existing \\"Category\\" node, through the \\"Category.children\\" relation.
  connect: [CategoryWhereUniqueInput!]

  # Disconnect existing \\"Category\\" nodes of the \\"Category.children\\" relation.
  disconnect: [CategoryWithForcedParentWhereUniqueInput!]

  # Update existing \\"Category\\" nodes and connect them to the existing \\"Category\\"
  # node, through the \\"Category.children\\" relation.
  update: [CategoryUpdateNestedUpdateChildrenInput!]

  # Create new \\"Category\\" nodes and connect them to the existing \\"Category\\" node, through the \\"Category.children\\" relation.
  create: [CategoryWithForcedParentCreateInput!]

  # Upsert existing \\"Category\\" nodes and connect them to the existing \\"Category\\"
  # node, through the \\"Category.children\\" relation.
  upsert: [CategoryUpdateNestedUpsertChildrenInput!]

  # Delete existing \\"Category\\" nodes from the \\"Category.children\\" relation.
  delete: [CategoryWithForcedParentWhereUniqueInput!]
}

input CategoryUpdateInput {
  # The public ID
  id: ID
  title: String

  # Nested actions for the \\"Category.parent\\" relation
  parent: CategoryUpdateParentInput

  # Nested actions for the \\"Category.articles\\" relation
  articles: CategoryUpdateArticlesInput

  # Nested actions for the \\"Category.children\\" relation
  children: CategoryUpdateChildrenInput
}

input CategoryUpdateNestedUpdateArticlesInput {
  where: ArticleWithOptionalCategoryWhereUniqueInput!
  data: ArticleWithForcedCategoryUpdateInput!
}

input CategoryUpdateNestedUpdateChildrenInput {
  where: CategoryWithOptionalParentWhereUniqueInput!
  data: CategoryWithForcedParentUpdateInput!
}

input CategoryUpdateNestedUpdateParentInput {
  where: CategoryWhereUniqueInput!
  data: CategoryUpdateInput!
}

input CategoryUpdateNestedUpsertArticlesInput {
  where: ArticleWithOptionalCategoryWhereUniqueInput!
  update: ArticleWithForcedCategoryUpdateInput!
  create: ArticleWithForcedCategoryCreateInput!
}

input CategoryUpdateNestedUpsertChildrenInput {
  where: CategoryWithOptionalParentWhereUniqueInput!
  update: CategoryWithForcedParentUpdateInput!
  create: CategoryWithForcedParentCreateInput!
}

input CategoryUpdateNestedUpsertParentInput {
  where: CategoryWhereUniqueInput!
  create: CategoryCreateInput!
  update: CategoryUpdateInput!
}

input CategoryUpdateParentInput {
  # Connect an existing \\"Category\\" node to the existing \\"Category\\" node, through the \\"Category.parent\\" relation.
  connect: CategoryWhereUniqueInput

  # Update an existing \\"Category\\" node and connect it to the existing \\"Category\\" node, through the \\"Category.parent\\" relation.
  update: CategoryUpdateNestedUpdateParentInput

  # Create a new \\"Category\\" node and connect it to the existing \\"Category\\" node, through the \\"Category.parent\\" relation.
  create: CategoryCreateInput

  # Create or update a \\"Category\\" node and connect it to the existing \\"Category\\" node, through the \\"Category.parent\\" relation.
  upsert: CategoryUpdateNestedUpsertParentInput

  # Disconnect the current connected \\"Category\\" node, if any, of the \\"Category.parent\\" relation.
  disconnect: Boolean
}

# Filters the \\"Category\\" nodes by specifying some conditions
input CategoryWhereInput {
  _id: Int
  _id_not: Int
  _id_in: [Int]
  _id_not_in: [Int]
  _id_lt: Int
  _id_lte: Int
  _id_gt: Int
  _id_gte: Int
  id: ID
  id_not: ID
  id_in: [ID]
  id_not_in: [ID]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime]
  createdAt_not_in: [DateTime]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime]
  updatedAt_not_in: [DateTime]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String]
  title_not_in: [String]
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  slug: String
  slug_not: String
  slug_in: [String]
  slug_not_in: [String]
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  parent: CategoryWhereInput
  parent_is_null: Boolean
  articles_some: ArticleWhereInput
  children_some: CategoryWhereInput
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: CategoryWhereInput
}

# Identifies exactly one \\"Category\\" node with one of these unique combinations of values:
# - _id
# - id
# - parent, slug
input CategoryWhereUniqueInput {
  _id: Int
  id: ID
  parent: CategoryWhereUniqueInput
  slug: String
}

input CategoryWithForcedParentCreateInput {
  # The public ID
  id: ID
  title: String!

  # The category's slug
  slug: String

  # Nested actions for the \\"Category.articles\\" relation
  articles: CategoryCreateArticlesInput

  # Nested actions for the \\"Category.children\\" relation
  children: CategoryCreateChildrenInput
}

input CategoryWithForcedParentUpdateInput {
  # The public ID
  id: ID
  title: String

  # Nested actions for the \\"Category.articles\\" relation
  articles: CategoryUpdateArticlesInput

  # Nested actions for the \\"Category.children\\" relation
  children: CategoryUpdateChildrenInput
}

# Given a forced \\"parent\\", identifies exactly one \\"Category\\" node.
input CategoryWithForcedParentWhereUniqueInput {
  slug: String!
}

# Given a known \\"parent\\", identifies exactly one \\"Category\\" node with one of these unique combinations of values:
# - _id
# - id
# - parent (optional), slug
input CategoryWithOptionalParentWhereUniqueInput {
  _id: Int
  id: ID
  parent: CategoryWhereUniqueInput
  slug: String
}

# A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
# \`date-time\` format outlined in section 5.6 of the RFC 3339 profile of the ISO
# 8601 standard for representation of dates and times using the Gregorian calendar.
scalar DateTime

type Mutation {
  # Create a single \\"Article\\" node.
  createArticle(data: ArticleCreateInput!): Article!

  # Delete a single \\"Article\\" node.
  deleteArticle(where: ArticleWhereUniqueInput!): Article

  # Update a single \\"Article\\" node.
  updateArticle(where: ArticleWhereUniqueInput!, data: ArticleUpdateInput!): Article

  # Update or create a single \\"Article\\" node.
  upsertArticle(where: ArticleWhereUniqueInput!, create: ArticleCreateInput!, update: ArticleUpdateInput!): Article!

  # Create a single \\"ArticleTag\\" node.
  createArticleTag(data: ArticleTagCreateInput!): ArticleTag!

  # Delete a single \\"ArticleTag\\" node.
  deleteArticleTag(where: ArticleTagWhereUniqueInput!): ArticleTag

  # Update a single \\"ArticleTag\\" node.
  updateArticleTag(where: ArticleTagWhereUniqueInput!, data: ArticleTagUpdateInput!): ArticleTag

  # Update or create a single \\"ArticleTag\\" node.
  upsertArticleTag(where: ArticleTagWhereUniqueInput!, create: ArticleTagCreateInput!, update: ArticleTagUpdateInput!): ArticleTag!

  # Create a single \\"ArticleTagComment\\" node.
  createArticleTagComment(data: ArticleTagCommentCreateInput!): ArticleTagComment!

  # Delete a single \\"ArticleTagComment\\" node.
  deleteArticleTagComment(where: ArticleTagCommentWhereUniqueInput!): ArticleTagComment

  # Update a single \\"ArticleTagComment\\" node.
  updateArticleTagComment(where: ArticleTagCommentWhereUniqueInput!, data: ArticleTagCommentUpdateInput!): ArticleTagComment

  # Update or create a single \\"ArticleTagComment\\" node.
  upsertArticleTagComment(where: ArticleTagCommentWhereUniqueInput!, create: ArticleTagCommentCreateInput!, update: ArticleTagCommentUpdateInput!): ArticleTagComment!

  # Create a single \\"ArticleUrl\\" node.
  createArticleUrl(data: ArticleUrlCreateInput!): ArticleUrl!

  # Delete a single \\"ArticleUrl\\" node.
  deleteArticleUrl(where: ArticleUrlWhereUniqueInput!): ArticleUrl

  # Update a single \\"ArticleUrl\\" node.
  updateArticleUrl(where: ArticleUrlWhereUniqueInput!, data: ArticleUrlUpdateInput!): ArticleUrl

  # Update or create a single \\"ArticleUrl\\" node.
  upsertArticleUrl(where: ArticleUrlWhereUniqueInput!, create: ArticleUrlCreateInput!, update: ArticleUrlUpdateInput!): ArticleUrl!

  # Create a single \\"ArticleUrlMeta\\" node.
  createArticleUrlMeta(data: ArticleUrlMetaCreateInput!): ArticleUrlMeta!

  # Delete a single \\"ArticleUrlMeta\\" node.
  deleteArticleUrlMeta(where: ArticleUrlMetaWhereUniqueInput!): ArticleUrlMeta

  # Update a single \\"ArticleUrlMeta\\" node.
  updateArticleUrlMeta(where: ArticleUrlMetaWhereUniqueInput!, data: Boolean!): ArticleUrlMeta

  # Update or create a single \\"ArticleUrlMeta\\" node.
  upsertArticleUrlMeta(where: ArticleUrlMetaWhereUniqueInput!, create: ArticleUrlMetaCreateInput!, update: Boolean!): ArticleUrlMeta!

  # Create a single \\"Category\\" node.
  createCategory(data: CategoryCreateInput!): Category!

  # Delete a single \\"Category\\" node.
  deleteCategory(where: CategoryWhereUniqueInput!): Category

  # Update a single \\"Category\\" node.
  updateCategory(where: CategoryWhereUniqueInput!, data: CategoryUpdateInput!): Category

  # Update or create a single \\"Category\\" node.
  upsertCategory(where: CategoryWhereUniqueInput!, create: CategoryCreateInput!, update: CategoryUpdateInput!): Category!

  # Create a single \\"Tag\\" node.
  createTag(data: TagCreateInput!): Tag!

  # Create a single \\"User\\" node.
  createUser(data: UserCreateInput!): User!

  # Delete a single \\"User\\" node.
  deleteUser(where: UserWhereUniqueInput!): User

  # Update a single \\"User\\" node.
  updateUser(where: UserWhereUniqueInput!, data: UserUpdateInput!): User

  # Update or create a single \\"User\\" node.
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!

  # Returns a JWT in case of success.
  login(login: String!, password: String!): String
}

type Query {
  # Retrieve the number of \\"Article\\" nodes.
  articleCount(where: ArticleWhereInput): Int!

  # Retrieve a list of \\"Article\\" nodes.
  articles(where: ArticleWhereInput, orderBy: [ArticleOrderByInput!], first: Int!, skip: Int): [Article!]!

  # Retrieve a single \\"Article\\" node.
  article(where: ArticleWhereUniqueInput!): Article

  # Retrieve the number of \\"ArticleTag\\" nodes.
  articleTagCount(where: ArticleTagWhereInput): Int!

  # Retrieve a list of \\"ArticleTag\\" nodes.
  articleTags(where: ArticleTagWhereInput, orderBy: [ArticleTagOrderByInput!], first: Int!, skip: Int): [ArticleTag!]!

  # Retrieve a single \\"ArticleTag\\" node.
  articleTag(where: ArticleTagWhereUniqueInput!): ArticleTag

  # Retrieve the number of \\"ArticleTagComment\\" nodes.
  articleTagCommentCount(where: ArticleTagCommentWhereInput): Int!

  # Retrieve a list of \\"ArticleTagComment\\" nodes.
  articleTagComments(where: ArticleTagCommentWhereInput, orderBy: [ArticleTagCommentOrderByInput!], first: Int!, skip: Int): [ArticleTagComment!]!

  # Retrieve a single \\"ArticleTagComment\\" node.
  articleTagComment(where: ArticleTagCommentWhereUniqueInput!): ArticleTagComment

  # Retrieve the number of \\"ArticleUrl\\" nodes.
  articleUrlCount(where: ArticleUrlWhereInput): Int!

  # Retrieve a list of \\"ArticleUrl\\" nodes.
  articleUrls(where: ArticleUrlWhereInput, orderBy: [ArticleUrlOrderByInput!], first: Int!, skip: Int): [ArticleUrl!]!

  # Retrieve a single \\"ArticleUrl\\" node.
  articleUrl(where: ArticleUrlWhereUniqueInput!): ArticleUrl

  # Retrieve the number of \\"ArticleUrlMeta\\" nodes.
  articleUrlMetaCount(where: ArticleUrlMetaWhereInput): Int!

  # Retrieve a list of \\"ArticleUrlMeta\\" nodes.
  articleUrlMetas(where: ArticleUrlMetaWhereInput, orderBy: [ArticleUrlMetaOrderByInput!], first: Int!, skip: Int): [ArticleUrlMeta!]!

  # Retrieve a single \\"ArticleUrlMeta\\" node.
  articleUrlMeta(where: ArticleUrlMetaWhereUniqueInput!): ArticleUrlMeta

  # Retrieve the number of \\"Category\\" nodes.
  categoryCount(where: CategoryWhereInput): Int!

  # Retrieve a list of \\"Category\\" nodes.
  categories(where: CategoryWhereInput, orderBy: [CategoryOrderByInput!], first: Int!, skip: Int): [Category!]!

  # Retrieve a single \\"Category\\" node.
  category(where: CategoryWhereUniqueInput!): Category

  # Retrieve the number of \\"Tag\\" nodes.
  tagCount(where: TagWhereInput): Int!

  # Retrieve a list of \\"Tag\\" nodes.
  tags(where: TagWhereInput, orderBy: [TagOrderByInput!], first: Int!, skip: Int): [Tag!]!

  # Retrieve a single \\"Tag\\" node.
  tag(where: TagWhereUniqueInput!): Tag

  # Retrieve the number of \\"User\\" nodes.
  userCount(where: UserWhereInput): Int!

  # Retrieve a list of \\"User\\" nodes.
  users(where: UserWhereInput, orderBy: [UserOrderByInput!], first: Int!, skip: Int): [User!]!

  # Retrieve a single \\"User\\" node.
  user(where: UserWhereUniqueInput!): User

  # A custom query.
  hello(name: String!, id: UserWhereUniqueInput!): User
}

# \\"Tag\\" resource's node
type Tag {
  # The public ID
  id: ID!

  # The date, fixed, of the document's creation
  createdAt: DateTime!

  # The date of the document's last update
  updatedAt: DateTime!
  title: String!

  # The tag's slug
  slug: String!

  # \\"ArticleTag.tag\\"'s inverse relation
  articles(where: ArticleTagWhereInput, orderBy: [ArticleTagOrderByInput!], first: Int!, skip: Int): [ArticleTag!]!

  # \\"ArticleTag.tag\\"'s inverse relation count
  articleCount(where: ArticleTagWhereInput): Int!
}

input TagCreateArticlesInput {
  # Create new \\"ArticleTag\\" nodes and connect them to the new \\"Tag\\" node, through the \\"Tag.articles\\" relation.
  create: [ArticleTagWithForcedTagCreateInput!]
}

input TagCreateInput {
  # The public ID
  id: ID
  title: String!

  # The tag's slug
  slug: String

  # Nested actions for the \\"Tag.articles\\" relation
  articles: TagCreateArticlesInput
}

enum TagOrderByInput {
  _id_ASC
  _id_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  title_ASC
  title_DESC
  slug_ASC
  slug_DESC
}

# Filters the \\"Tag\\" nodes by specifying some conditions
input TagWhereInput {
  _id: Int
  _id_not: Int
  _id_in: [Int]
  _id_not_in: [Int]
  _id_lt: Int
  _id_lte: Int
  _id_gt: Int
  _id_gte: Int
  id: ID
  id_not: ID
  id_in: [ID]
  id_not_in: [ID]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime]
  createdAt_not_in: [DateTime]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime]
  updatedAt_not_in: [DateTime]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String]
  title_not_in: [String]
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  slug: String
  slug_not: String
  slug_in: [String]
  slug_not_in: [String]
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  articles_some: ArticleTagWhereInput
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  NOT: TagWhereInput
}

# Identifies exactly one \\"Tag\\" node with one of these unique values:
# - _id
# - id
# - slug
input TagWhereUniqueInput {
  _id: Int
  id: ID
  slug: String
}

# \\"User\\" resource's node
type User {
  # The public ID
  id: ID!

  # The date, fixed, of the document's creation
  createdAt: DateTime!

  # The date of the document's last update
  updatedAt: DateTime!

  # The user's username
  username: String!

  # \\"Article.author\\"'s inverse relation
  authorOfArticles(where: ArticleWhereInput, orderBy: [ArticleOrderByInput!], first: Int!, skip: Int): [Article!]!

  # \\"Article.author\\"'s inverse relation count
  authorOfArticleCount(where: ArticleWhereInput): Int!

  # \\"Article.moderator\\"'s inverse relation
  moderatorOfArticles(where: ArticleWhereInput, orderBy: [ArticleOrderByInput!], first: Int!, skip: Int): [Article!]!

  # \\"Article.moderator\\"'s inverse relation count
  moderatorOfArticleCount(where: ArticleWhereInput): Int!
}

input UserCreateAuthorOfArticlesInput {
  # Connect existing \\"Article\\" nodes to the new \\"User\\" node, through the \\"User.authorOfArticles\\" relation.
  connect: [ArticleWhereUniqueInput!]

  # Create new \\"Article\\" nodes and connect them to the new \\"User\\" node, through the \\"User.authorOfArticles\\" relation.
  create: [ArticleWithForcedAuthorCreateInput!]
}

input UserCreateInput {
  # The public ID
  id: ID

  # The user's username
  username: String!

  # Nested actions for the \\"User.authorOfArticles\\" relation
  authorOfArticles: UserCreateAuthorOfArticlesInput

  # Nested actions for the \\"User.moderatorOfArticles\\" relation
  moderatorOfArticles: UserCreateModeratorOfArticlesInput
}

input UserCreateModeratorOfArticlesInput {
  # Connect existing \\"Article\\" nodes to the new \\"User\\" node, through the \\"User.moderatorOfArticles\\" relation.
  connect: [ArticleWhereUniqueInput!]

  # Create new \\"Article\\" nodes and connect them to the new \\"User\\" node, through the \\"User.moderatorOfArticles\\" relation.
  create: [ArticleWithForcedModeratorCreateInput!]
}

enum UserOrderByInput {
  _id_ASC
  _id_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  username_ASC
  username_DESC
}

input UserUpdateAuthorOfArticlesInput {
  # Connect existing \\"Article\\" nodes to the existing \\"User\\" node, through the \\"User.authorOfArticles\\" relation.
  connect: [ArticleWhereUniqueInput!]

  # Update existing \\"Article\\" nodes and connect them to the existing \\"User\\" node,
  # through the \\"User.authorOfArticles\\" relation.
  update: [UserUpdateNestedUpdateAuthorOfArticlesInput!]

  # Create new \\"Article\\" nodes and connect them to the existing \\"User\\" node, through the \\"User.authorOfArticles\\" relation.
  create: [ArticleWithForcedAuthorCreateInput!]

  # Upsert existing \\"Article\\" nodes and connect them to the existing \\"User\\" node,
  # through the \\"User.authorOfArticles\\" relation.
  upsert: [UserUpdateNestedUpsertAuthorOfArticlesInput!]

  # Delete existing \\"Article\\" nodes from the \\"User.authorOfArticles\\" relation.
  delete: [ArticleWhereUniqueInput!]
}

input UserUpdateInput {
  # The public ID
  id: ID

  # Nested actions for the \\"User.authorOfArticles\\" relation
  authorOfArticles: UserUpdateAuthorOfArticlesInput

  # Nested actions for the \\"User.moderatorOfArticles\\" relation
  moderatorOfArticles: UserUpdateModeratorOfArticlesInput
}

input UserUpdateModeratorOfArticlesInput {
  # Connect existing \\"Article\\" nodes to the existing \\"User\\" node, through the \\"User.moderatorOfArticles\\" relation.
  connect: [ArticleWhereUniqueInput!]

  # Disconnect existing \\"Article\\" nodes of the \\"User.moderatorOfArticles\\" relation.
  disconnect: [ArticleWhereUniqueInput!]

  # Update existing \\"Article\\" nodes and connect them to the existing \\"User\\" node,
  # through the \\"User.moderatorOfArticles\\" relation.
  update: [UserUpdateNestedUpdateModeratorOfArticlesInput!]

  # Create new \\"Article\\" nodes and connect them to the existing \\"User\\" node, through the \\"User.moderatorOfArticles\\" relation.
  create: [ArticleWithForcedModeratorCreateInput!]

  # Upsert existing \\"Article\\" nodes and connect them to the existing \\"User\\" node,
  # through the \\"User.moderatorOfArticles\\" relation.
  upsert: [UserUpdateNestedUpsertModeratorOfArticlesInput!]

  # Delete existing \\"Article\\" nodes from the \\"User.moderatorOfArticles\\" relation.
  delete: [ArticleWhereUniqueInput!]
}

input UserUpdateNestedUpdateAuthorOfArticlesInput {
  where: ArticleWhereUniqueInput
  data: ArticleWithForcedAuthorUpdateInput!
}

input UserUpdateNestedUpdateModeratorOfArticlesInput {
  where: ArticleWhereUniqueInput
  data: ArticleWithForcedModeratorUpdateInput!
}

input UserUpdateNestedUpsertAuthorOfArticlesInput {
  where: ArticleWhereUniqueInput!
  update: ArticleWithForcedAuthorUpdateInput!
  create: ArticleWithForcedAuthorCreateInput!
}

input UserUpdateNestedUpsertModeratorOfArticlesInput {
  where: ArticleWhereUniqueInput!
  update: ArticleWithForcedModeratorUpdateInput!
  create: ArticleWithForcedModeratorCreateInput!
}

# Filters the \\"User\\" nodes by specifying some conditions
input UserWhereInput {
  _id: Int
  _id_not: Int
  _id_in: [Int]
  _id_not_in: [Int]
  _id_lt: Int
  _id_lte: Int
  _id_gt: Int
  _id_gte: Int
  id: ID
  id_not: ID
  id_in: [ID]
  id_not_in: [ID]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime]
  createdAt_not_in: [DateTime]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime]
  updatedAt_not_in: [DateTime]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  username: String
  username_not: String
  username_in: [String]
  username_not_in: [String]
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  authorOfArticles_some: ArticleWhereInput
  moderatorOfArticles_some: ArticleWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: UserWhereInput
}

# Identifies exactly one \\"User\\" node with one of these unique values:
# - _id
# - id
# - username
input UserWhereUniqueInput {
  _id: Int
  id: ID
  username: String
}
"
`;
